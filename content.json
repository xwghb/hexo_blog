{"pages":[],"posts":[{"title":"个人介绍","text":"博主介绍XiaoW 下面就是我的照片，献丑了 说明该个人博客展示的博客多来自我个人的csdn博客","link":"/hexo_blog/2021/08/19/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"},{"title":"python爬取b站视频","text":"[TOC] 起因不知道兄弟们有没有遇到过b站视频经常下架的问题，就比如我现在想在b站找一个老师的课程，运气好可以找到，但经常看了一段时间之后可能就会下架，然后继续找，过不了多久又会下架，这样的循环搞得我好烦呀，这时候我突然想起来万能的python，python爬b站视频咋样？说干就干 前期准备python环境必不可少，同时需要ffmpeg，一台可以上网的电脑 分析首先随便打开一个视频，然后右键查看网页源代码由于展示的源代码格式有点乱，所以我选择复制到vscode中查看这时候看着就舒服多了，细心的朋友可能已经发现baseUrl，然后我们复制一下这个baseUrl，在浏览器中打开康康，果然不出所料还是老实巴交的用python访问吧，header头设置好之后就可以直接访问了，至于header头怎么设置，相信兄弟们都懂，一切就绪之后可以拿到这个文件，值得注意的是b站的视频文件和音频文件是分开存储的，因此我们还需要下载音频文件，音频文件url的位置和视频文件url的位置靠很近，就在audio这里存放着 这样音频文件和视频文件的地址我么都拿到了，随后就可以开始下载了，下载之后使用ffmpeg将两个文件操作一下就可以了。这里有ffmpeg的安装教程，大家可以看一下，ffmpeg安装教程，欢迎三连 代码音频和视频整合的工具类1234567891011import os# 声音视频结合def videoMixAudio(videourl, audiourl, mp4url): com = f'D:\\\\tool\\\\ffmpeg\\\\bin\\\\ffmpeg.exe -i &quot;{audiourl}&quot; -i &quot;{videourl}&quot; ' \\ f'-acodec copy -vcodec copy &quot;{mp4url}&quot;' os.system(com) os.remove(videourl) os.remove(audiourl) 这里解释一下。videourl是视频文件的全路径，audiourl是音频文件的全路径，mp4url则是生成的有声音的视频的位置，然后通过调用ffmpeg来对音频和视频文件进行合成，没有使用ffmpeg的同学们可以采用格式工厂的方式对这两个文件操作进行操作也是可以的。 分析页面使用到了这三个匹配规则 123456# 拿到&lt;script&gt;中的内容valink = re.compile(r'&lt;script&gt;(.*?)&lt;/script&gt;')# 拿到window.__playinfo__后面的内容infoink = re.compile(r'window.__playinfo__=(.*)')# 这个是为了拿到视频的名字 可以选择不用nameink = re.compile(r'window.__INITIAL_STATE__=(.*);\\(function') valink用于取出下图这个部分的内容infoink是为了把window._playinfo_去掉，这样拿到的就是可以转换为json的字符串这样就可以拿到视频和音频的url了代码如下 12345678910111213141516171819def downloadVideo(url): # 获取网页源代码 html = requests.get(url).text # 拿到script的内容 info = re.findall(valink, html) # 第一个就是playinfo的那个script info2 = str(info[0]) # 这一个是存放视频信息的scripte info3 = str(info[1]) nameAnd=re.findall(nameink,info3) # 把window._playinfo_去掉，拿到一个可以转换为json的字符串 videoAndAudio = re.findall(infoink, info2) # str转json jsonobject = json.loads(videoAndAudio[0]) nameobject = json.loads(nameAnd[0]) name=nameobject[&quot;videoData&quot;][&quot;title&quot;] # 获取视频和音频的链接 videoFile = jsonobject[&quot;data&quot;][&quot;dash&quot;][&quot;video&quot;][0][&quot;baseUrl&quot;] audioFile = jsonobject[&quot;data&quot;][&quot;dash&quot;][&quot;audio&quot;][0][&quot;baseUrl&quot;] 拿到链接之后就可以开始下载了，记住下载的时候要设置好header 成果 总结全部代码就不贴了，兄弟们按照这个流程就可以实现，过程还是比较简单的，自己用用就好。希望和大家一起进步","link":"/hexo_blog/2021/08/20/python%E7%88%AC%E5%8F%96b%E7%AB%99%E8%A7%86%E9%A2%91/"},{"title":"Harmony开发样例","text":"@[TOC](开发一个可以看小姐姐照片的鸿蒙应用 鸿蒙开发入门) 效果图先整张效果图，丑点是丑点，但可以用，买不起鸿蒙系统手机的我，只配用虚拟机。 前言要说目前最火的手机操作系统，要我来看的话那必然是鸿蒙无疑。16号刚刚结束了第五次鸿蒙内测，在看到这次的内测名单之后，居然有970的机器，这是不是说明俺这手里奋战了三年的荣耀play也可以生鸿蒙了，但现实是970三孤儿果然名不虚传，还是没有我们。那么言归正传，这次突然想做一个基于鸿蒙的小demo，然后又想到了我之前爬取的小姐姐图片链接还没有用武之地，这俩是不是可以结合一下？上次有这样的想法还是上一次，那么就做一个看小姐姐的小demo吧，开整开整。 实现思路之前在网上看到有直接把图片下载下来然后放进项目中的，这个很明显不适合我，不仅占的空间大，而且图片还得手动更新，这可不行 我们采用的是调用图片链接接口获取所有的图片链接，一个链接只是一个字符串要比图片占的空间小太多了，将这些链接存储在内存中，有兴趣的可以存在数据库里，然后每次随机获取一条链接就可以，由这条链接获取图片信息，将图片渲染到页面就可以。 整个流程简单的一塌糊涂，总结一下就是 拿取图片链接 由链接获取图片信息 渲染至显示页面 具体实现建立项目这个比较基础了，就不说了，如果不大了解的兄弟们，直接去官方文档看看就可以，建立流程非常简单。 建立http链接拿取图片链接设置网络权限我们需要访问网络，就必须要设置网络权限，来到config.json文件中，添加以下内容 1234567891011121314&quot;reqPermissions&quot;: [ { &quot;name&quot;: &quot;ohos.permission.INTERNET&quot; }, { &quot;name&quot;: &quot;com.wxr.xiaowpic.DataAbilityShellProvider.PROVIDER&quot; }, { &quot;name&quot;: &quot;ohos.permission.GET_NETWORK_INFO&quot; }, { &quot;name&quot;: &quot;ohos.permission.SET_NETWORK_INFO&quot; } ], 直接在module中添加如上内容，如下图 设置允许http请求这里注意，重点哈，鸿蒙默认的是发起https请求，因此如果我们发起http请求是会报错的，这里需要修改一下还是在config.json下，在deviceConfig中添加以下内容 12345&quot;default&quot;: { &quot;network&quot;: { &quot;cleartextTraffic&quot;: true } } 如下图所示，这里吐槽一下，我再寻找怎么设置允许发起http响应的时候，发现好多文章都一样，而且都不适用于我这个项目，还有的人复制别人的文章也能复制错，绝了。 发起http请求，并获取返回的数据json数据解析这里要使用到alibaba的fastjson工具类，在build.gradle引入如下依赖 1implementation group: 'com.alibaba', name: 'fastjson', version: '1.2.73' 如下图所示 发起请求，获得响应内容这里使用的是大佬封装好的专门用于请求接口的一个工具，ZZRHttp，同样需要引入依赖，引入过程和上面fastjson引入过程一致。 1implementation 'com.zzrv5.zzrhttp:ZZRHttp:1.0.1' 获取接口数据的具体实现如下，这里解释一下，https://2fd8e89d.cpolar.io/getAll这个接口地址，是获取图片链接的，是我本地的服务，所以大家如果需要的话，我可以把我的服务代码发给你们，包括存储图片链接的数据库。 12345678910111213141516171819202122232425ZZRHttp.get(&quot;https://2fd8e89d.cpolar.io/getAll&quot;, new ZZRCallBack.CallBackString() { @Override public void onFailure(int code, String errorMessage) { //http访问出错，此部分在主线程中工作,可以更新UI等操做。 MyLabel.error(&quot;访问图片链接接口出错&quot;); new ToastDialog(getContext()).setText(&quot;网络连接出问题了，请稍后重试&quot;).show(); } @Override public void onResponse(String response) { //http访问成功，此部分在主线程中工作，可以更新UI等操作。 MyLabel.info(&quot;获取图片链接成功&quot;); new ToastDialog(getContext()).setText(&quot;正在初始化，稍后&quot;).show(); //将字符串转换为json对象 JSONObject jsonObject = JSONObject.parseObject(response); //将其中返回的图片链接转换为列表 JSONArray info = (JSONArray) jsonObject.get(&quot;info&quot;); MyLabel.info(&quot;拿取数据量：&quot; + info.size()); info.forEach(item -&gt; { srcs.add(item.toString()); }); new ToastDialog(getContext()).setText(&quot;初始化成功，开始你的快乐吧&quot;).show(); MyLabel.info(&quot;内存中数据数量&quot; + srcs.size()); } }); 将获取的图片链接放入内存中就是声明一个静态列表变量，目的是为了下次获取图片链接时可以直接在这里拿取图片链接 123456789101112131415161718192021222324252627282930313233343536373839public void initData() { PicDao picDao = new PicDaoImpl(getContext()); //使用后台线程进行初始化 TaskDispatcher refreshUITask = createParallelTaskDispatcher(&quot;&quot;, TaskPriority.DEFAULT); refreshUITask.syncDispatch(() -&gt; {// List&lt;PicSrc&gt; list = picDao.list(); //判断内存中有无数据 if (srcs.size() == 0) { MyLabel.info(&quot;内存中没东西，第一次打开应用&quot;); MyLabel.info(&quot;调用图片接口获取图片链接列表&quot;); ZZRHttp.get(&quot;https://2fd8e89d.cpolar.io/getAll&quot;, new ZZRCallBack.CallBackString() { @Override public void onFailure(int code, String errorMessage) { //http访问出错，此部分在主线程中工作,可以更新UI等操做。 MyLabel.error(&quot;访问图片链接接口出错&quot;); new ToastDialog(getContext()).setText(&quot;网络连接出问题了，请稍后重试&quot;).show(); } @Override public void onResponse(String response) { //http访问成功，此部分在主线程中工作，可以更新UI等操作。 MyLabel.info(&quot;获取图片链接成功&quot;); new ToastDialog(getContext()).setText(&quot;正在初始化，稍后&quot;).show(); JSONObject jsonObject = JSONObject.parseObject(response); JSONArray info = (JSONArray) jsonObject.get(&quot;info&quot;); MyLabel.info(&quot;拿取数据量：&quot; + info.size()); info.forEach(item -&gt; { srcs.add(item.toString()); }); new ToastDialog(getContext()).setText(&quot;初始化成功，开始你的快乐吧&quot;).show(); MyLabel.info(&quot;内存中数据数量&quot; + srcs.size()); } }); } else { MyLabel.info(&quot;已经有内容了&quot;); } }); } 获取网络图片并展示在页面上http请求工具类这个类的主要作用就是发起http请求，并返回响应字节流，其实就是获取图片的字节流，代码如下 12345678910111213141516171819202122232425262728293031323334353637package com.wxr.xiaowpic.util;import com.wxr.xiaowpic.label.MyLabel;import com.zzrv5.mylibrary.ZZRCallBack;import com.zzrv5.mylibrary.ZZRHttp;import ohos.hiviewdfx.HiLog;import ohos.utils.net.Uri;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;public class HttpUtils { //url就是要访问的网络资源，methodType就是请求方式 public static InputStream getInput(String url,String methodType){ InputStream inputStream = null; try { URL url1=new URL(url); HttpURLConnection urlConnection = (HttpURLConnection) url1.openConnection(); urlConnection.setRequestMethod(methodType); urlConnection.connect(); int rescode=urlConnection.getResponseCode(); if(rescode==HttpURLConnection.HTTP_OK){ inputStream=urlConnection.getInputStream(); } } catch (Exception e) { HiLog.error(MyLabel.LABEL_LOG,e.getMessage()); HiLog.error(MyLabel.LABEL_LOG,e.getCause().toString()); } return inputStream; } } 字节流转图片工具类没啥好说的，复制就可以用 1234567891011121314151617181920212223242526272829303132333435package com.wxr.xiaowpic.util;import com.wxr.xiaowpic.label.MyLabel;import ohos.hiviewdfx.HiLog;import ohos.hiviewdfx.HiLogLabel;import ohos.media.image.ImageSource;import ohos.media.image.PixelMap;import java.io.InputStream;public class ImageUtils { private static final HiLogLabel LABEL_LOG = new HiLogLabel(3, 0xD001100, &quot;XiaoW&quot;); public static PixelMap createPixelMap(String imageUrl) {//获取图片字节流信息 InputStream inputStream = HttpUtils.getInput(imageUrl,&quot;GET&quot;); PixelMap pixelMap=null; ImageSource.SourceOptions sourceOptions = new ImageSource.SourceOptions(); sourceOptions.formatHint = &quot;image/jpeg&quot;; HiLog.info(MyLabel.LABEL_LOG,(inputStream==null)+&quot;&quot;); try { ImageSource imageSource = ImageSource.create(inputStream,sourceOptions); pixelMap = imageSource.createPixelmap(null); } catch (Exception e){ HiLog.info(LABEL_LOG,e.getMessage()); } return pixelMap; }} 图片展示在页面这里采用的是按钮点击之后进行图片的渲染，其中图片链接是在我们获取的图片链接随机读取一个，然后将该照片渲染至页面 123456789101112131415161718192021222324button.setClickedListener(new Component.ClickedListener() { @Override public void onClick(Component component) { TaskDispatcher refreshUITask = createParallelTaskDispatcher(&quot;&quot;, TaskPriority.DEFAULT); refreshUITask.syncDispatch(() -&gt; { //在链接列表中随机取一个数据 int index = (int) (Math.random() * srcs.size()); MyLabel.info(srcs.get(index)); String url=srcs.get(index); MyLabel.info(&quot;开始获取图片&quot;); //访问线上图片 PixelMap pixelMap = ImageUtils.createPixelMap(url); getContext().getUITaskDispatcher().asyncDispatch(new Runnable() { @Override public void run() { //Image组件填充位图数据，ui界面更新 image.setPixelMap(pixelMap); pixelMap.release(); } }); }); } }); 总结之前没有自己做过移动端的demo，总之收获还是不少的，所以期间出了不少问题，需要全部代码的兄弟们私信就好。","link":"/hexo_blog/2021/08/19/Harmony%E5%BC%80%E5%8F%91%E6%A0%B7%E4%BE%8B/"}],"tags":[{"name":"随笔","slug":"随笔","link":"/hexo_blog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"python","slug":"python","link":"/hexo_blog/tags/python/"},{"name":"Harmony","slug":"Harmony","link":"/hexo_blog/tags/Harmony/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/hexo_blog/categories/%E9%9A%8F%E7%AC%94/"},{"name":"爬虫","slug":"爬虫","link":"/hexo_blog/categories/%E7%88%AC%E8%99%AB/"},{"name":"java","slug":"java","link":"/hexo_blog/categories/java/"}]}