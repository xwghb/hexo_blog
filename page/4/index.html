<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>xiaow的博客</title><link rel="manifest" href="/hexo_blog/manifest.json"><meta name="application-name" content="xiaow的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="xiaow的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="个人技术博客"><meta property="og:type" content="blog"><meta property="og:title" content="xiaow的博客"><meta property="og:url" content="https://xiaow123.gitee.io/hexo_blog"><meta property="og:site_name" content="xiaow的博客"><meta property="og:description" content="个人技术博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/img/og_image.png"><meta property="article:author" content="xiaow"><meta property="article:tag" content="java,python"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/hexo_blog/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaow123.gitee.io/hexo_blog"},"headline":"xiaow的博客","image":["https://xiaow123.gitee.io/hexo_blog/img/og_image.png"],"author":{"@type":"Person","name":"xiaow"},"publisher":{"@type":"Organization","name":"xiaow的博客","logo":{"@type":"ImageObject","url":"https://xiaow123.gitee.io/img/logo.svg"}},"description":"个人技术博客"}</script><link rel="icon" href="/hexo_blog/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/hexo_blog/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/hexo_blog/"><img src="/hexo_blog/img/logo.svg" alt="xiaow的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/hexo_blog/">主页</a><a class="navbar-item" href="/hexo_blog/archives">归档</a><a class="navbar-item" href="/hexo_blog/categories">分类</a><a class="navbar-item" href="/hexo_blog/tags">标签</a><a class="navbar-item" href="https://xiaow123.gitee.io/staicpage/html/mine/">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-01-22T08:51:20.000Z" title="2022-1-22 16:51:20">2022-01-22</time>发表</span><span class="level-item"><time dateTime="2022-02-12T13:37:38.746Z" title="2022-2-12 21:37:38">2022-02-12</time>更新</span><span class="level-item">38 分钟读完 (大约5643个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/">jvm续集</a></h1><div class="content"><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="G1（garbage-first）垃圾回收器"><a href="#G1（garbage-first）垃圾回收器" class="headerlink" title="G1（garbage first）垃圾回收器"></a>G1（garbage first）垃圾回收器</h2><ul>
<li>同步注重吞吐量和地言辞，默认暂停目标是200ms</li>
<li>超大堆内存，会将堆划分为多个大小相同的Region，每个region可独立为老年代+新生代，划分多个region有利于加快速度</li>
<li>整体上是标记+整理算法，两个region之间是复制算法</li>
<li>g1在堆内存越来越大时，优势越大</li>
</ul>
<p>-XX:+UseG1GC    使用G1垃圾回收器（JDK9之后默认为G1）</p>
<h3 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220122165806077.png" alt="image-20220122165806077"></p>
<p>YC–》YC+CM–》MC</p>
<p><strong>三者是循环进行的</strong></p>
<h4 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h4><p>下图为多个region，最开始为空，E代表伊甸园，最开始对象分配到伊甸园区</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220122170128118.png" alt="image-20220122170128118"></p>
<p>E区占满之后会进行minor gc，将幸村对象存放在幸存区</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123100635232.png" alt="image-20220123100635232"></p>
<p>当幸存区空间不足时，会将寿命达到阈值的移动到老年去，而那些未到年龄的则到新的幸存区</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123100948952.png" alt="image-20220123100948952"></p>
<h4 id="Young-Collection-CM-concurrent-mark"><a href="#Young-Collection-CM-concurrent-mark" class="headerlink" title="Young Collection + CM(concurrent mark)"></a>Young Collection + CM(concurrent mark)</h4><ul>
<li><p>YOUNG GC进行初始标记</p>
</li>
<li><p>老年代占用空间比例到达阈值时，会进行并发标记（不会stw），阈值可由下面的参数决定         -XX: InitiatingHeapOccupancyPercent=percent（默认45%）</p>
<p>o为老年区</p>
</li>
</ul>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123101456335.png" alt="image-20220123101456335"></p>
<h4 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h4><ul>
<li>对E，S，O三个区进行整体的回收</li>
<li>E中对象分配到S中，S中年龄达到阈值的会晋升到老年区</li>
<li>在整理o区时，系统会选择进行回收之后，可以拿出更多空间的o区，进行回收，将其中非垃圾的复制到另一个o中，<strong>从而实现在最大时间下可以完成这些垃圾回收</strong>  </li>
<li>会进行最终标记，会stw</li>
<li>进行拷贝存活，会stw</li>
</ul>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123101707678.png" alt="image-20220123101707678"></p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><ul>
<li><p>SerialGC</p>
<ul>
<li>新生代内存不足发生的垃圾收集- minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
</li>
<li><p>ParallelGc</p>
<ul>
<li>新生代内存不足发生的垃圾收集- minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
</li>
<li><p>CMS</p>
<ul>
<li>新生代内存不足发生的垃圾收集- minor gc</li>
<li>老年代内存不足</li>
</ul>
</li>
<li><p>G1</p>
<ul>
<li>新生代内存不足发生的垃圾收集- minor gc</li>
<li>老年代内存不足<ul>
<li>内存比例达到阈值(默认45%)，就会出发第二阶段和第三阶段回收</li>
<li>如果这两个阶段回收速度可以赶上产生垃圾的速度，就不需要发生full gc</li>
<li>若赶不上就会开始串行收集，导致stw</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="新生代垃圾回收的跨代引用"><a href="#新生代垃圾回收的跨代引用" class="headerlink" title="新生代垃圾回收的跨代引用"></a>新生代垃圾回收的跨代引用</h3><p>根对象有一部分是来自老年代，新生代回收在进行标记时会需要查找这些根对象来进行判断那些需要回收，即垃圾，这时对老年代中所有对象进行扫描，有些耗费时间，这时就开始采用<strong>卡表</strong>的方式来对那些老年代中可做根对象的区域进行标记，称为<strong>脏卡</strong>,这时在进行回收时，直接扫描脏卡区域就可以，从而减小扫描范围，提高速度。</p>
<p><strong>这里为了方便，老年区会划分为多个区域，方便来对脏卡的标记。</strong></p>
<p>这里E区中也有<strong>Remember Set</strong>记录有哪些脏卡来引用当前E中的对象。</p>
<p>当引用变化时会及时更新脏卡，这里更新是一个异步过程，放在一个队列中进行处理</p>
<p>concurrent refinement threads更新 Remembered Set</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123171646379.png" alt="image-20220123171646379"></p>
<h3 id="Remark（重新标记阶段）"><a href="#Remark（重新标记阶段）" class="headerlink" title="Remark（重新标记阶段）"></a>Remark（重新标记阶段）</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123172913086.png" alt="image-20220123172913086"></p>
<ul>
<li>黑色已经处理完成，灰色尚在处理，白色未被处理</li>
<li>处理结束之后，黑色代表不是垃圾，白色是垃圾</li>
</ul>
<h4 id="为什么重新标记"><a href="#为什么重新标记" class="headerlink" title="为什么重新标记"></a>为什么重新标记</h4><p>因为在标记阶段是并发进行的，这时我们已经检测完A对象为垃圾，需要进行回收，但此时B对象作为不可回收的对象，有引用了A对象，此时A不应回收，但是我们已经标记A为可回收，此时就出现了错误，因此需要remark来对其进行重新标记</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>如果检测到在并发标记过程中，某对象的引用发生了变化，就需要对其进行<strong>写屏障</strong>，并将该对象放在队列中，在重新标记时对队列中的对象进行处理，重新对其进行标记。</p>
<h3 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h3><ul>
<li>jdk8中是用char数组来存放String对象</li>
<li>将所有新分配的字符串放入一个队列中</li>
<li>新生代回收时，G1并发检查是否有字符串重复</li>
<li>若值相同，则俩者引用同一个char数组</li>
<li>与串池的区别<ul>
<li>串池关注的是String对象</li>
<li>字符串关注的是char[]</li>
<li>二者在jvm内部使用不同的字符串表</li>
</ul>
</li>
<li>默认开启，模拟机参数为   -XX:+UseStringDeduplication（默认启用）</li>
<li>略微占用了cpu时间，回收时间稍长，但是总体性能有所提高</li>
</ul>
<h3 id="并发标记类卸载"><a href="#并发标记类卸载" class="headerlink" title="并发标记类卸载"></a>并发标记类卸载</h3><p>-XX:+ClassUnloadinglwithConcurrentMark 默认启用</p>
<p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类</p>
<h3 id="回收巨型对象"><a href="#回收巨型对象" class="headerlink" title="回收巨型对象"></a>回收巨型对象</h3><ul>
<li>一个对象大于一个region的一半，成为巨型对象</li>
<li>G1不会拷贝巨型对象</li>
<li>回收优先考虑巨型对象</li>
<li>G1会跟踪老年代所有incoming引用，这样老年代 incoming引用为o的巨型对象就可以在新生代垃圾回收时处理掉（人话：如果巨型对象不被引用时，就可以在新生代进行回收，总之回收越早越好）</li>
</ul>
<h3 id="JDK-9-并发标记起始时间的调整"><a href="#JDK-9-并发标记起始时间的调整" class="headerlink" title="JDK 9 并发标记起始时间的调整"></a>JDK 9 并发标记起始时间的调整</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123213257610.png" alt="image-20220123213257610"></p>
<h2 id="垃圾回收的调优"><a href="#垃圾回收的调优" class="headerlink" title="垃圾回收的调优"></a>垃圾回收的调优</h2><h3 id="查看使用的GC"><a href="#查看使用的GC" class="headerlink" title="查看使用的GC"></a>查看使用的GC</h3><p>java   -XX:+PrintFlagsFinal -version / findstr “GC”</p>
<h2 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h2><h3 id="最快的gc是不进行gc"><a href="#最快的gc是不进行gc" class="headerlink" title="最快的gc是不进行gc"></a>最快的gc是不进行gc</h3><ul>
<li>数据是否太多</li>
<li>数据是否表示太臃肿<ul>
<li>尽可能使用基本类型，从而减少内存使用</li>
</ul>
</li>
<li>是否存在内存泄漏</li>
</ul>
<h2 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h2><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124095420031.png" alt="image-20220124095420031"></p>
<p>TLAB是每个线程独自占有的伊甸园中的一片区域</p>
<h3 id="新生代越大越好吗"><a href="#新生代越大越好吗" class="headerlink" title="新生代越大越好吗"></a>新生代越大越好吗</h3><ul>
<li>太小，会导致可用空间太少，一旦发现空间不足，就会开始新生代回收</li>
<li>太大，会导致老年代空间较小，即使新生代很空闲，但是老年代已经不够了，此时就会触发full gc，此时浪费的时间更多</li>
<li>新生代占的大小为堆的四分之一到二分之一最好</li>
</ul>
<h3 id="幸存区的大小设置"><a href="#幸存区的大小设置" class="headerlink" title="幸存区的大小设置"></a>幸存区的大小设置</h3><ul>
<li><p>要可以保留当前活跃对象和需要晋升的对象，一旦存储不下之后，老年区也会存储需要晋升的的对象，这就导致了有些对象生存时间并不长，但是这些对象进入了老年代，就导致了他活得时间太长了</p>
</li>
<li><p>长时间存活对象尽早晋升，要设置合理的晋升阈值</p>
<p><strong>设置阈值</strong></p>
<p>-XX:MaxTenuringThreshold=threshold</p>
<p><strong>打印对象寿命信息</strong></p>
<p>-XX:+PrintTenuringDistribution</p>
</li>
</ul>
<h3 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124103224214.png" alt="image-20220124103224214"></p>
<h2 id="调优案例"><a href="#调优案例" class="headerlink" title="调优案例"></a>调优案例</h2><h3 id="gc频繁"><a href="#gc频繁" class="headerlink" title="gc频繁"></a>gc频繁</h3><p>若是minor gc过于频繁，可能原因是新生代内存设置过小，此时可能导致gc频繁，从而使得响应时间增大，同样当新生代幸存区已经无力存放幸村对象时，就会导致这些对象放置在老年区，使得有些原本在 m gc阶段就可以清理的对象，必须要到full gc时期清理，从而导致了资源的浪费</p>
<p><strong>解决方案</strong></p>
<p>增大幸存区的大小即可</p>
<h3 id="请求时期发生了full-gc，单次时间较长"><a href="#请求时期发生了full-gc，单次时间较长" class="headerlink" title="请求时期发生了full gc，单次时间较长"></a>请求时期发生了full gc，单次时间较长</h3><p>remark之前先进行新生代的回收</p>
<h3 id="老年代充裕下，发生了full-gc"><a href="#老年代充裕下，发生了full-gc" class="headerlink" title="老年代充裕下，发生了full gc"></a>老年代充裕下，发生了full gc</h3><p>1.7之前，元空间不足也会引起full gc</p>
<h2 id="类加载与字节码技术"><a href="#类加载与字节码技术" class="headerlink" title="类加载与字节码技术"></a>类加载与字节码技术</h2><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124105713457.png" alt="image-20220124105713457"></p>
<h3 id="字节码文件"><a href="#字节码文件" class="headerlink" title="字节码文件"></a>字节码文件</h3><p><strong>生成字节码文件</strong></p>
<p>javac -parameters -d . test.java</p>
<h4 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h4><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124111003865.png" alt="image-20220124111003865"></p>
<p><strong>魔数</strong></p>
<p>0-3字节，表示为class类型文件</p>
<p>ca fe ba be</p>
<p><strong>版本</strong></p>
<p>4-7字节       （16进制）00 34（52）–》jdk 8</p>
<p><strong>常量池</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124113203660.png" alt="image-20220124113203660"></p>
<p>8-9 常量池的长度， 00 23（35），表示#1-#34，#0不计入，也没有值</p>
<p><strong>而后一个字节一项</strong>，方法字节后面留有4个字节，作为方法信息</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124114348241.png" alt="image-20220124114348241"></p>
<p>这个东西，字节码是十六进制的，因此两位就是一个字节，前两位是类型，后面的内容就看情况而定</p>
<p><strong>访问标识和继承信息</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124203429617.png" alt="image-20220124203429617"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124203702217.png" alt="image-20220124203702217"></p>
<p><strong>成员变量</strong></p>
<p>以下为了更好查找类名，在常量池中存放以下信息，一一对应</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124203741911.png" alt="image-20220124203741911"></p>
<p><strong>方法信息</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124203844892.png" alt="image-20220124203844892"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124203939358.png" alt="image-20220124203939358"></p>
<p>方法属性，就像方法中的代码，就被称为code属性，代码属性</p>
<p>如上图，按顺序来</p>
<p>00 01 是访问修饰，是一个公共的方法还是其他的</p>
<p>00 07 是方法的名字</p>
<p>00 08 方法参数</p>
<p>00 01 方法属性的数量</p>
<p>00 09 常量池中对应属性</p>
<p>00 00 00 2f 27 代表后面内容的长度</p>
<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124210041225.png" alt="image-20220124210041225"></p>
<h3 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h3><p>javap -v test.class </p>
<p>-v代表详细信息</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124211310398.png" alt="image-20220124211310398"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124210923095.png" alt="image-20220124210923095"></p>
<p>dscriptor 参数类型</p>
<p>flags 代表方法是public和static修饰的（访问修饰符）</p>
<p>stack 最大操作栈深度</p>
<p>locals 局部变量表的长度</p>
<p>args_size 参数的个数</p>
<p>前面的数字代表字节码的行号</p>
<p><strong>line 这里的行号：对应字节码中的</strong></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125104219048.png" alt="image-20220125104219048"></p>
<p>类加载器将main所在的类进行类加载</p>
<p>常量池的内容到运行时常量池（属于方法区）</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125105005284.png" alt="image-20220125105005284"></p>
<p>比较小的数字，存储在方法的字节码里，<strong>但一旦超过了Short的范围，就存储在常量池中</strong></p>
<p>方法字节码存入到方法区</p>
<p>main线程开始运行分配栈帧内存，绿色的为局部变量表，蓝色为操作数栈，分别对应上述字节码文件中的stack（数量）与locals（深度）</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125105157164.png" alt="image-20220125105157164"></p>
<p>之后执行引擎就开始执行字节码的命令</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125105647350.png" alt="image-20220125105647350"></p>
<ul>
<li><p>bipush10，将10压入操作数栈中</p>
</li>
<li><p>istore1 将操作数栈中的内容送到栈帧局部变量的1号槽位（槽位编号由左向右，由0开始）</p>
</li>
<li><p>ldc #3 取出运行时常量池中的第三项，放入操作数栈</p>
</li>
<li><p>istore 2 将操作数栈的内容放入局部变量表中2号槽位</p>
</li>
<li><p>iload_1 将局部变量表中的一号槽位的内容加载至操作数栈</p>
</li>
<li><p>iload_2 与上面同理</p>
</li>
<li><p>iadd 弹出两个变量，计算后，放入操作数栈中</p>
</li>
<li><p>getstatic #4 通过常量池的内容，来获取堆中out对象的引用，将该对象引用（地址）放入至操作数中</p>
</li>
<li><p>invokevirtual #5 在常量池中找出5号内容，找到新的方法，再分配一个新的栈帧，将栈顶的内容传递给新的栈帧，新方法结束之后，会将栈帧将方法栈中弹出，然后清空操作数栈，return就结束，同时主方法的栈帧在方法栈中也被弹出</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125111252811.png" alt="image-20220125111252811"></p>
</li>
</ul>
<h3 id="a"><a href="#a" class="headerlink" title="a++"></a>a++</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125112517212.png" alt="image-20220125112517212"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125141547292.png" alt="image-20220125141547292"></p>
<ul>
<li>iinc 是在局部变量上直接进行加一</li>
<li>a++ 是先load在iinc</li>
<li>++a 实现iinc在load</li>
<li>iinc  槽位，自增值</li>
</ul>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125142241912.png" alt="image-20220125142241912"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125142335805.png" alt="image-20220125142335805"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125142355639.png" alt="image-20220125142355639"></p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125142922335.png" alt="image-20220125142922335"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125143057342.png" alt="image-20220125143057342"></p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="cinit-V-整个类的构造方法"><a href="#cinit-V-整个类的构造方法" class="headerlink" title="cinit() V            整个类的构造方法"></a>cinit() V            整个类的构造方法</h4><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125144615624.png" alt="image-20220125144615624"></p>
<p>会将所有的静态代码块进行以下整合，整合之后，在类创建时，会从上至下进行执行</p>
<h4 id="init（）V-每个实例对象的构造方法"><a href="#init（）V-每个实例对象的构造方法" class="headerlink" title="init（）V                    每个实例对象的构造方法"></a>init（）V                    每个实例对象的构造方法</h4><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125145433813.png" alt="image-20220125145433813"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125151511169.png" alt="image-20220125151511169"></p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125151846730.png" alt="image-20220125151846730"></p>
<p>字节码如下</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125152637383.png" alt="image-20220125152637383"></p>
<ul>
<li>new 分配内存，分配成功将对象的引用放入操作数栈</li>
<li>dup 复制栈顶的地址，都是刚刚new出的引用</li>
<li>invokespecial  #3     调用栈顶引用的方法 （#3对应常量池的方法），调用结束后，引用会被删除</li>
<li>astore_1 将另一个对象引用存储到局部变量表中</li>
<li>aload_1 在局部变量表中引入</li>
<li>pop是将刚刚调入的引用删除掉，因为后面要执行静态方法，不需要该对象</li>
</ul>
<p>invokestatic和invokespecial都是调用确定的方法，例如像是静态方法，构造方法，私有方法，这一类直接可以找到方法的入口地址。</p>
<p>invokevirtual则是去调用那些不确定的方法，例如public这一类的，这一类可被重写，需要多次访问获取方法的入口地址，因此会动态进行调用，即动态绑定</p>
<h3 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h3><p>来到jdk目录下输入以下命令，启动hsdb工具</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure>

<p>进入图形界面attach 进程id</p>
<p>禁用指针压缩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseCompressedOops -XX:-UsecompressedClassPointers</span><br></pre></td></tr></table></figure>

<p>file下连接到Hotspot process</p>
<p>tools下选择  find object by query</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125163804574.png" alt="image-20220125163804574"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125163727447.png" alt="image-20220125163727447"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125164403679.png" alt="image-20220125164403679"></p>
<p>这里就是class的底层结构</p>
<p>分为对象头和成员变量，该对象只有对象头</p>
<p>前八字节是对象markword，锁标记等</p>
<p>后八字节是类型指针</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125165450657.png" alt="image-20220125165450657"></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">          i=<span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">          i=<span class="number">20</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127101135580.png" alt="image-20220127101135580"></p>
<p>上图为字节码文件</p>
<p>exception table中就是存储着处理异常的位置</p>
<p>由2到5，监管位置不包括尾，即不对第五行进行异常监督</p>
<p>若出现异常会与监管的异常相匹配则会跳到target指向的位置</p>
<p>八号这里的astore_2就是将异常对象存入到变量表中</p>
<p><strong>关于多个异常处理和判断异常这里写出代码反编译就可以理解</strong></p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           i=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           i=<span class="number">20</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            i=<span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节码文件</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127102606835.png" alt="image-20220127102606835"></p>
<p>astore_3 是将并非我们要补获的异常存储到3号槽中，然后aload3则是将该异常取出来，在由athrow进行抛出</p>
<h5 id="面试题1"><a href="#面试题1" class="headerlink" title="面试题1"></a>面试题1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回2</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127103754894.png" alt="image-20220127103754894"></p>
<p>由字节码可以看出，仅仅将1存储到局部变量表，最终返回的却是2，</p>
<p>出现异常时也类似解读</p>
<p>这也出现了问题，finally中出现了return，就会吞掉异常这就导致了异常不被捕获</p>
<h5 id="面试题2"><a href="#面试题2" class="headerlink" title="面试题2"></a>面试题2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">          i=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>字节码文件</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127104931777.png" alt="image-20220127104931777"></p>
<p>整体的思路就是将要返回的值保存到局部变量表中，等到finally时也还是会返回刚刚要返回的值</p>
<h3 id="symchronized"><a href="#symchronized" class="headerlink" title="symchronized"></a>symchronized</h3><p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节码文件</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127110246682.png" alt="image-20220127110246682"></p>
<p>dup对o进行复制两次引用</p>
<p>第一个引用用于调用构造方法</p>
<p>第二个放入局部常量表中</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127110816075.png" alt="image-20220127110816075"></p>
<h2 id="编译期处理"><a href="#编译期处理" class="headerlink" title="编译期处理"></a>编译期处理</h2><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>java编译器将*.java源码编译为class文件的过程中，自动生成和转换的以写代码，主要为了减轻程序员的负担，成为语法糖</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>尽管我们没有设置构造方法，jvm会自动帮我们生成一个构造方法，在字节码中可以体现</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127112511263.png" alt="image-20220127112511263"></p>
<p>这里的字节码文件里还是给我们生成了构造方法</p>
<h3 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h3><p>即java的<strong>基本类型与包装类型之间会有自动的类型转换</strong>，是在JDK5之后加入的</p>
<p>如下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Integer x=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> y=x;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>装箱</strong>：基本类型到封装类型</p>
<p><strong>拆箱</strong>：封装到基本类型</p>
<h3 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h3><p>泛型也是在JDK 5开始加入的特性，但java在编译泛型代码后会执行泛型擦除的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了Object类型来处理;</p>
<p>如下图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     list.add(<span class="number">10</span>);</span><br><span class="line">    Integer integer = list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节码文件</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127113256813.png" alt="image-20220127113256813"></p>
<p>由14行命令可以看出，当泛型对象生成结束之后，而后在对泛型对象操作时并不会按照泛型的类型来调用方法，而是直接按照一律object来处理，这就是泛型的擦除</p>
<p>在返回时也是直接返回object，但是返回之后会在27这里进行一下类型的转换，也就是checkcast</p>
<h2 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220210111658333.png" alt="image-20220210111658333"></p>
<p>例如访问String时，先访问String.class（这就是_java_mirror），通过这个class在调用instanceKlass在进行操作</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220210112358422.png" alt="image-20220210112358422"></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li><p>验证：验证类是否符合JVM规范，安全性检查</p>
</li>
<li><p>准备：为static变量分配空间，设置默认值（分配空间与赋值是分开的）</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220210114608344.png" alt="image-20220210114608344"></p>
<p>测试代码如下</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220210115258406.png" alt="image-20220210115258406"></p>
</li>
<li><p>解析</p>
<p>将常量池中的符号引用解析为直接引用</p>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>其实就是<strong>cinit</strong>阶段，虚拟机需保证这个各类的构造方法的线程安全</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220211095631243.png" alt="image-20220211095631243"></p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220211101849309.png" alt="image-20220211101849309"></p>
<p>由上而下，加载器的优先级依次减小，优先级小的加载器加载类时需要先询问优先级高的是否加载过，从而判断是否要加载，例如ac问ec，ec问bc。这种委托方式称为双亲委派的加载模式。</p>
<p>bc无法直接由java调用，因为bc是c++写的。</p>
<h3 id="Bootstrap-Classloader（启动器加载类）"><a href="#Bootstrap-Classloader（启动器加载类）" class="headerlink" title="Bootstrap Classloader（启动器加载类）"></a>Bootstrap Classloader（启动器加载类）</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220211102649011.png" alt="image-20220211102649011"></p>
<p>/a后追加的路径就是将该路径追加至jre/lib下，从而调用bc</p>
<h3 id="Extention-classloader（扩展器加载类）"><a href="#Extention-classloader（扩展器加载类）" class="headerlink" title="Extention classloader（扩展器加载类）"></a>Extention classloader（扩展器加载类）</h3><p><strong>打jar包</strong></p>
<p>因为需要打成jar包放在ec地文件目录下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf my.jar com/xiaow/**.class</span><br></pre></td></tr></table></figure>

<p>放在ec的目录下，这样在new时，会一级一级向上查询，优先级高的进行加载</p>
<p>就不会使用ac加载</p>
<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>委派上级优先做类的加载，若上级没有再由本级进行加载</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220211112432509.png" alt="image-20220211112432509"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220211112539658.png" alt="image-20220211112539658"></p>
<p>大致的过程就是先是一步步向上级调用，来查找目标class，一旦parent为null，代表上级已是bc，此时直接调用特定方法，由bc进行加载，若加载为空，则由本层加载，然后返回加载的值，下级收到之后在进行判断是否进行查找或直接返回</p>
<p>每级被调用时都需要在本级中查找一下是否已经加载了</p>
<h3 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h3><p>这里仔细看看</p>
<p>目前理解：并未采取双亲加载机制进行加载，而是采用直接调用ac进行加载</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220211185711483.png" alt="image-20220211185711483"></p>
<ul>
<li>不同的类加载器加载的类并不是同一个</li>
<li>加载器相同，包名和类名相同才被认为是一个class</li>
</ul>
<h4 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h4><p>这里主要是要重写findclass方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String path = <span class="string">&quot;D:\\java\\&quot;</span> + name + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            ByteArrayOutputStream out=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            Files.copy(Paths.get(path),out);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = out.toByteArray();</span><br><span class="line">            Class&lt;?&gt; aClass = defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> aClass;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>加载自定义位置的类</strong></p>
<p>这里采用了暴力反射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; xiaoW = myClassLoader.loadClass(<span class="string">&quot;xiaow&quot;</span>);</span><br><span class="line">            Field[] declaredFields = xiaoW.getDeclaredFields();</span><br><span class="line">            Field a = xiaoW.getDeclaredField(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            a.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object o = xiaoW.newInstance();</span><br><span class="line">            a.setInt(o,<span class="number">2</span>);</span><br><span class="line">            System.out.println(a.getInt(o));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h2><p>若多次进行相同的操作，运行的时间会慢慢减少</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220212122519292.png" alt="image-20220212122519292"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220212122621352.png" alt="image-20220212122621352"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220212122734240.png" alt="image-20220212122734240"></p>
<p><strong>热点代码</strong>：就是执行次数较多的代码</p>
<p><strong>逃逸分析</strong>：观察对象是否会被使用，如果外层不调用该对象，称为不逃逸，这时就不创建对象，C2对字节码进行修改</p>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220212172141517.png" alt="image-20220212172141517"></p>
<p>如上，如果热点方法的内容不是太长，会直接把代码取出来，直接执行，这就称为内联</p>
<p><strong>打印内联信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+unlockDiagnosticvoptions -XX:+PrintInlining</span><br></pre></td></tr></table></figure>

<h3 id="字段优化"><a href="#字段优化" class="headerlink" title="字段优化"></a>字段优化</h3><h2 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h2><p>前十六次调用时会调用本地方法（c++编写），速度比较慢，一旦第十七次之后就开始采用由运行期间动态生成的访问器，这时苏幅就快了</p>
<p>例如反射执行对象的方法时，最开始invoke是调用本地方法进行，在调用次数达到一个阈值之后就会开始调用动态生成的访问器</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220212181746804.png" alt="image-20220212181746804"></p>
<p>这里可以看出来，十七次时调用的invoke实际上是已经开始直接调用该方法了，并未通过反射，效率自然就快要赶上直接调用了。</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220212181859082.png" alt="image-20220212181859082"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-01-21T08:00:40.000Z" title="2022-1-21 16:00:40">2022-01-21</time>发表</span><span class="level-item"><time dateTime="2022-01-22T13:15:28.786Z" title="2022-1-22 21:15:28">2022-01-22</time>更新</span><span class="level-item">39 分钟读完 (大约5777个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2022/01/21/jvm/">jvm</a></h1><div class="content"><!-- toc -->

<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>java二进制字节码运行环境</p>
<ul>
<li><p>一次编写，到处运行的基础    jvm对外提供了一致的运行环境</p>
</li>
<li><p>自动内存管理机制—垃圾回收功能 </p>
</li>
<li><p>数组下标越界检查 有些语言无法进行检查，可能导致越界的数组数据占据了其他程序的空间</p>
</li>
<li><p>多态 </p>
<h2 id="jre与jvm"><a href="#jre与jvm" class="headerlink" title="jre与jvm"></a>jre与jvm</h2></li>
</ul>
<p>jvm+基础类库——–jre</p>
<p>jre+编译工具——–jdk</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220105164423893.png" alt="image-20220105164423893"></p>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p><img src="/hexo_blog/2022/01/21/jvm/image-20220118204306920.png" alt="image-20220118204306920"></p>
<p>java源码—–》二进制字节码——–》解释器翻译为机器语言——–》cpu来执行</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220105165457742.png" alt="image-20220105165457742"></p>
<h3 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h3><p>记录下一条jvm指令的执行地址，</p>
<p>例如指令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 lalalal</span><br><span class="line">2 啦啦啦啦啦</span><br></pre></td></tr></table></figure>

<p>1执行时，会将2放入程序计数器中，待1执行结束之后就在程序计数器中取得2进行执行，这样依次进行执行</p>
<p>一般是使用寄存器来实现的</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>线程私有</strong> 每一个线程都有自己的程序计数器，当分给该线程的时间片结束之后，假如线程还未完成，则需要进行记录下一条指令的地址，等到重新分配时间片时可以继续执行该程序</li>
<li><strong>不会内存溢出</strong></li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>每个线程需要一个栈，存放着多个栈帧，一个栈帧对应一个方法，每个方法运行时需要的内存</p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><ul>
<li>参数</li>
<li>局部变量</li>
<li>返回地址</li>
</ul>
<p>一个栈中可以有多个栈帧</p>
<p>每个线程只能有一个活动栈帧（）</p>
<p>这里方法调用的栈可以在idea中直观看到</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220113164920042.png" alt="image-20220113164920042"></p>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><ul>
<li><p>垃圾回收不涉及到栈内存</p>
</li>
<li><p>栈内存大小可通过 -Xss size 来设置程序栈大小</p>
<ul>
<li><p>windows取决于虚拟内存大小</p>
</li>
<li><p>linux/macos/Oracle默认为1024kb</p>
</li>
<li><p>并不是栈越大越好，栈越大可运行的线程越少</p>
</li>
<li><p>idea通过以下方式进行设置</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220113171844104.png" alt="image-20220113171844104"></p>
</li>
</ul>
</li>
<li><p>局部变量是否线程安全</p>
<ul>
<li>就看变量是线程私有的还是共享的</li>
<li>线程私有就不需要考虑线程是否安全，共享的话就需要考虑</li>
<li>如果方法内的局部变量未逃离方法作用范围，就是线程安全的，例如如果该变量作为返回值，那么其他线程就可能会拿到这个变量，那么就会导致不安全</li>
</ul>
</li>
</ul>
<h4 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h4><ul>
<li><p>栈内存放的栈帧数量超出了栈的大小就回导致占内存溢出===》递归就可以做到，一直递归不停，就会产生栈内存溢出 </p>
</li>
<li><p>栈帧过大也会导致栈内存溢出</p>
</li>
</ul>
<h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p><strong>定位</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">top：定位哪一个进程对cpu占用高</span><br><span class="line"></span><br><span class="line">ps H -eo pid,tid,%cpu | grep 进程id：进一步定位哪一个线程引起的 </span><br><span class="line">jstack 进程id：列出该进程的所有的线程的信息</span><br></pre></td></tr></table></figure>



<p><strong>长时间未输出结果</strong></p>
<p> jstack 进程id 列出所有的线程信息，可以展示出死锁信息</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法不是由java编写的，因为java无法直接与计算机底层进行交互，因此需要通过本地方法来进行对底层的交互，一般本地方法是由c或c++编写的。</p>
<p>这些本地方法利用的就是本地方法栈 </p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>线程共享的，需要考虑线程安全问题</li>
<li>new创建的对象都是存放在堆</li>
<li>有垃圾回收机制</li>
</ul>
<h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p>不断生成新对象，并且所有对象一直在使用，就会导致堆内存溢出</p>
<p>修改堆空间大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx 8m</span><br></pre></td></tr></table></figure>

<p>以下代码可以用来测试堆空间是否溢出的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">     String s=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     List&lt;String&gt; list =<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     count=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">         s=s+s;</span><br><span class="line">         list.add(s);</span><br><span class="line">         count++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">     System.out.println(count);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>启示</strong></p>
<p>服务器内存越跑越小，可能是因为有一些内存未被来得及回收</p>
<h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><ul>
<li><p>jps工具：查看系统中有哪些java进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure></li>
<li><p>jmap工具：查看堆内存占用情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程id</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">byte</span> array[]=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line">          System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">          array=<span class="keyword">null</span>;</span><br><span class="line">          System.gc();</span><br><span class="line">          System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>jconsole工具：有ui的，多功能的检测工具</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jconsole</span><br></pre></td></tr></table></figure>

<ul>
<li>jvisualvm</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>存放方法，构造器，成员属性之类的数据</p>
<p>方法区在虚拟机启动时就创建，逻辑上是堆的组成部分，但不同的厂商不一定按照这个实现</p>
<h4 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h4><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>常量池： </p>
<p>就是一张常量表，虚拟机指令根据这张常量表找到要执行的类名和方法名，参数类型，字面量等信息</p>
<p>运行时常量池：</p>
<p>常量池是*.class中的，当该类被加载，他的常量池信息就会放入运行时常量池中，并且把里面的符号地址变为真实地址</p>
<h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v Main.class</span><br></pre></td></tr></table></figure>

<p>这里编译的class文件在out文件夹下</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220114113857338.png" alt="image-20220114113857338"></p>
<p>如下图就是常量池</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220114114710142.png" alt="image-20220114114710142"></p>
<h4 id="常量池加载过程"><a href="#常量池加载过程" class="headerlink" title="常量池加载过程"></a>常量池加载过程</h4><p><img src="/hexo_blog/2022/01/21/jvm/image-20220118155538144.png" alt="image-20220118155538144"></p>
<p>最开始时常量池中是没有数据的，是在一步步加载中填入的，是一种懒加载机制</p>
<ul>
<li>常量池存放常量的结构是hash表，每次需要常量时就会以常量在hash表中查找，若不存在则创建</li>
</ul>
<h4 id="常量池与串池的区别"><a href="#常量池与串池的区别" class="headerlink" title="常量池与串池的区别"></a>常量池与串池的区别</h4><p>运行常量池（constant pool）中存放的仅仅是符号，而并非对象，串池（StringTable）中存放的则是字符串对象，作用就是防止创建重复的字符对象</p>
<h4 id="1-6和1-8中常量池和串池存放位置的差别"><a href="#1-6和1-8中常量池和串池存放位置的差别" class="headerlink" title="1.6和1.8中常量池和串池存放位置的差别"></a>1.6和1.8中常量池和串池存放位置的差别</h4><p><img src="/hexo_blog/2022/01/21/jvm/image-20220118165905767.png" alt="image-20220118165905767"></p>
<h4 id="StringTable（串池）的垃圾回收"><a href="#StringTable（串池）的垃圾回收" class="headerlink" title="StringTable（串池）的垃圾回收"></a>StringTable（串池）的垃圾回收</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx16m -XX: +PrintStringTablestatistics -XX: +PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>

<p>-Xmx16m ：设置堆的大小</p>
<p>-XX: +PrintStringTablestatistics ：打印串池中的对象信息</p>
<p>-XX: +PrintGCDetails -verbose:gc : 若存在垃圾回收，则进行打印信息</p>
<p>-XX: StringTableSize=200000 : 因为串池的结构是数组加链表这种方式，数组中的一个关键字称为一个桶，这里就是设计桶的数量，桶的数量越大性能越好，但相对的占用空间就可能过大，造成资源浪费</p>
<h4 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h4><ul>
<li>可以适当调大STringTable的数组长度也就是桶的数量，可以减少冲突从而使得查找效率得到提升</li>
<li>使用串池可对系统性能进行调优，若是<strong>new出来的字符串对象只存在堆中，并不会进入串池</strong>中，这时若是存在大量的重复的字符串对象，可以采用串池来对这些数据进行<strong>去重</strong>，所谓去重就是将利用串池的特性将大量的重复的字符串对象只存储一个字符串对象，其他对象只是对其的引用</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p><strong>操作系统内存</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220118204448078.png" alt="image-20220118204448078"></p>
<h4 id="ByteBuffer为什么读写更快"><a href="#ByteBuffer为什么读写更快" class="headerlink" title="ByteBuffer为什么读写更快"></a>ByteBuffer为什么读写更快</h4><p>使用ByteBuffer实际上就是通过直接内存进行读取</p>
<p><strong>传统io操作</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220119123425858.png" alt="image-20220119123425858"></p>
<p>因为java无法直接访问系统资源，因此需要再建立一个java缓冲区，整个过程就是：本地文件==》系统缓存==》java缓存==》使用</p>
<p><strong>直接内存的io方式</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220119123622038.png" alt="image-20220119123622038"></p>
<p>此时文件直接放入直接内存缓冲区中，java可以直接读取，减少了一层缓冲区，从而使得速度得到提升</p>
<h4 id="直接内存的溢出"><a href="#直接内存的溢出" class="headerlink" title="直接内存的溢出"></a>直接内存的溢出</h4><p>因为DM不受java垃圾机制管理，因此可能会出现内存溢出问题</p>
<p><strong>测试代码</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220119124146715.png" alt="image-20220119124146715"></p>
<h4 id="直接内存分配与释放的原理"><a href="#直接内存分配与释放的原理" class="headerlink" title="直接内存分配与释放的原理"></a>直接内存分配与释放的原理</h4><p>通过代码来申请直接内存的大小，这里直接内存不受jvm管理，因此需要在任务管理器里查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer=ByteBuffer.allocateDirect(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>直接内存的回收是通过unsafe对象来进行回收的</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220119152850973.png" alt="image-20220119152850973"></p>
<h4 id="禁用显示回收的影响"><a href="#禁用显示回收的影响" class="headerlink" title="禁用显示回收的影响"></a>禁用显示回收的影响</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.gc（）     <span class="comment">//显式的垃圾回收</span></span><br></pre></td></tr></table></figure>

<p>关闭显示垃圾回收机制，即System.gc（）无效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC    </span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>即有一个引用该对象，则计数器加一，为0则释放，</p>
<p><strong>弊端</strong></p>
<p>循环引用：即A引用B,B也引用A，没有其他引用他们，但是他们互相引用，都无法释放，就会导致内存泄漏</p>
<h4 id="可达性分析算法（java中使用的垃圾回收机制）"><a href="#可达性分析算法（java中使用的垃圾回收机制）" class="headerlink" title="可达性分析算法（java中使用的垃圾回收机制）"></a>可达性分析算法（java中使用的垃圾回收机制）</h4><p><strong>根对象</strong>：肯定不可以当作垃圾回收的对象</p>
<p>如果一个对象没有被根对象引用，就可以回收</p>
<p><strong>解析</strong></p>
<p>扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</p>
<p><strong>抓取当前堆使用的快照</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump :format=b,live,file=<span class="number">1.</span>bin <span class="number">21384</span></span><br></pre></td></tr></table></figure>

<p>-dump ==》存储</p>
<p>format=b ==》存储二进制文件</p>
<p>live ==》只记录那些未被垃圾回收的内容</p>
<p>file=1.bin 设置存储文件</p>
<p>21384 进程id（jps获取活动的java的进程id）</p>
<p><strong>mat查看gc root对象</strong></p>
<p>System class 系统对象</p>
<p>Busy Monitor 加锁的对象</p>
<p>Thread 活动线程中的对象，局部对象所引用的对象可左gcroot，同时参数中对象也是可以作为gcroot对象</p>
<p><strong>可以作为GC Root的对象</strong></p>
<p>System class 系统对象</p>
<p>Busy Monitor 加锁的对象</p>
<p>Thread 活动线程中的对象，局部对象所引用的对象可左gcroot，同时参数中对象也是可以作为gcroot对象</p>
<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><p><img src="/hexo_blog/2022/01/21/jvm/image-20220119162157683.png" alt="image-20220119162157683"></p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>例如new出来的就是强引用</p>
<p><strong>特点</strong></p>
<ul>
<li>只要沿着gc root链可以找到该对象，就无法被垃圾回收，例B对A-A4，以及ByteBuffer</li>
<li>只要没有直接或则间接对其强引用之后就可以垃圾回收了</li>
</ul>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p><strong>特点</strong></p>
<ul>
<li>只要未被gc root直接引用，垃圾回收时就会自动回收，例从C到软引用再到A2，当然此时需要B不在引用A2时，就可以发生垃圾回收</li>
</ul>
<p><strong>应用场景</strong></p>
<p>强引用下导致堆空间溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 强引用会导致堆空间不够用</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">int</span> _1M=<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">     List&lt;<span class="keyword">byte</span>[]&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M*<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>软引用下</p>
<p>在这种方式下其实就是使用软引用进行嵌套强引用，也就是SoftReference嵌套byte数组，从而达到软引用的目的，这样一旦出现堆内存不够就会进行释放软引用对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">    SoftReference softReference=<span class="keyword">new</span> SoftReference(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M*<span class="number">2</span>]);</span><br><span class="line">    list.add(softReference);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个过程中一旦出现了堆空间不够，就会清理软引用对象引用的对象，但是此时软引用对象还在，虽然占据内存比较小，但最好还是清理一下</p>
<p>使用引用队列进行处理，下方代码，关联了软引用队列，软引用关联的对象回收时，软引用对象会加入队列中，从而实现回收</p>
<p>这里我个人的理解就是判断这些软引用有没有引用其他对象，如果没有，则将其在队列中删除，从而将队列对软引用对象的强引用解除掉，从而实现对象的回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 关联了软引用队列，软引用关联的对象回收时，软引用对象会加入队列中，从而实现回收</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; referenceQueue=<span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">     List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">         SoftReference softReference=<span class="keyword">new</span> SoftReference(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M*<span class="number">2</span>],referenceQueue);</span><br><span class="line">         list.add(softReference);</span><br><span class="line">     &#125;</span><br><span class="line">     Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = referenceQueue.poll();</span><br><span class="line">     <span class="keyword">while</span>(poll!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         referenceQueue.remove();</span><br><span class="line">         poll=referenceQueue.poll();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p><strong>特点</strong></p>
<ul>
<li>当没有强引用时，若内存不够会回收软引用的对象，无论够不够都会回收弱引用对象</li>
<li>释放之后，因为软弱引用仍占用空间，因此需将二者放入引用队列中，进行循环依次释放空间</li>
</ul>
<p><strong>应用实例</strong></p>
<h4 id="虚引用（必须配合引用队列）"><a href="#虚引用（必须配合引用队列）" class="headerlink" title="虚引用（必须配合引用队列）"></a>虚引用（必须配合引用队列）</h4><p><img src="/hexo_blog/2022/01/21/jvm/image-20220121110409118.png" alt="image-20220121110409118"></p>
<p>之前的bytebuffer就是需要一个虚引用对象Cleaner，因为ByteBuffer若是在强引用引用结束之后，会对其进行回收，但是此时直接内存不由jvm管理，这就需要把虚引用对象放置在引用队列中，从而实现对直接内存的回收（虚引用对象就是Cleaner，来调用Unsafe的Free memory（）来进行释放）</p>
<h4 id="终结器引用（必须配合引用队列）"><a href="#终结器引用（必须配合引用队列）" class="headerlink" title="终结器引用（必须配合引用队列）"></a>终结器引用（必须配合引用队列）</h4><p>例如A对象重写了finalize，并且A即将被垃圾回收，会调用finalize方法，将放置一个终结器引用到队列中，会有一个优先级很低的线程会来检查队列中有无需要释放的引用，从而实现对象的回收</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><ul>
<li>判断哪些对象未被gcroot对象引用，对其进行标记</li>
<li>对标记对象进行清除，将对象的首地址存储在队列中，在新的对象分配地址时，会在队列中进行查找，判断有无空间，在进行分配</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>清除速度快</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>会产生大量的碎片空间，导致总剩余空间虽然足够，但有些大空间对象仍无法分配到足够的内存，导致内存溢出</li>
</ul>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><ul>
<li>判断哪些对象未被gcroot对象直接或间接引用，对其进行标记</li>
<li>清楚时，将可用的对象向前移动，从而使得内存空间更见紧凑，从而实现空间更加连续</li>
</ul>
<p><strong>优点</strong></p>
<p>没有内存碎片</p>
<p><strong>缺点</strong></p>
<p>耗费时间较多，例如如果有引用对象引用就是将移动的对象，需要修改大量内容，造成浪费时间</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="/hexo_blog/2022/01/21/jvm/image-20220121121912340.png" alt="image-20220121121912340"></p>
<p>划分成两片区域，将from中存活的对对象复制到to中，待复制结束之后就对from所有的对象进行回收，然后交换from与to的位置</p>
<p><strong>优点</strong></p>
<ul>
<li>没有碎片空间</li>
</ul>
<p><strong>缺点</strong></p>
<p>需要占用双倍的内存空间</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>三种算法都会协同工作</p>
<h3 id="大对象直接到老年代"><a href="#大对象直接到老年代" class="headerlink" title="大对象直接到老年代"></a>大对象直接到老年代</h3><p>超过新生代大小时，直接到老年代中存放</p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p><img src="/hexo_blog/2022/01/21/jvm/image-20220121122327319.png" alt="image-20220121122327319"></p>
<ul>
<li>长时间使用的放在老年代中，用完即弃的放在新生代中，也可以认为重要的，常用的在老年代中，而不常使用的在新生代中</li>
<li>清理时先清理新生代，如果内存实在不够，再开始清理老年代</li>
</ul>
<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><ul>
<li>最开始对象存放在伊甸园中</li>
<li>一旦伊甸园中内存占满之后，就会开始触发垃圾回收<strong>（Minor GC，新生代回收）</strong></li>
<li>先进行标记，然后将存活的对象复制到幸存区，将复制的对象<strong>寿命+1</strong>.然后交换from与to的位置，伊甸园剩余的对象就可以销毁了</li>
<li>然后又可以向伊甸园中分配对象，直到伊甸园又满了，继续执行上述操作，并且也需要测试from中有没有可以回收的，最后在进行回收伊甸园中与幸存区的对象</li>
<li><strong>幸存区中的寿命超过一个阈值（最大寿命15次，存放寿命的数据是4bit，存放在对象里，4位）之后就会晋升到老年代中，若新生代承受不下了，即使没有到达阈值，也会放在老年代中</strong></li>
<li><strong>minor gc会引发 stop the world，在垃圾回收时需暂停其他用户的线程，直到垃圾回收之后在恢复其他线程的运行</strong></li>
</ul>
<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><ul>
<li>当老年代中内存不足，会先触发minor gc，如果之后空间仍不足，则会触发老年代回收<strong>（Full GC）</strong>，这次回收会将老年代中和新生代中的对象进行回收，也会引起stop the world，并且持续时间更长</li>
<li>老年代中存活的对象很多，并且采用的算法可能是标记清除或标记清理，时间会长。</li>
<li>若full gc 之后仍无从充足空间，则full of mememory error</li>
</ul>
<h3 id="GC参数"><a href="#GC参数" class="headerlink" title="GC参数"></a>GC参数</h3><table>
<thead>
<tr>
<th>含义</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>堆初始大小</td>
<td>-Xms</td>
</tr>
<tr>
<td>堆最大大小</td>
<td>-Xmx或-XX:MaxHeapSize =size</td>
</tr>
<tr>
<td>新生代大小</td>
<td>-Xmn或(-XX:NewSize-size + -XX:MaxNewSize-size )</td>
</tr>
<tr>
<td>幸存区比例(动态)</td>
<td>-XX:InitialSurvivorRatio-ratio和-XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td>幸存区比例（ratio是指伊甸园所在比例）</td>
<td>-XX:SurvivorRatio= ratio</td>
</tr>
<tr>
<td>晋升阈值</td>
<td>-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td>晋升详情</td>
<td>-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td>GC详情</td>
<td>-XX:+PrintGCDetails -verbose:ge</td>
</tr>
<tr>
<td>FullGC前MinorGC</td>
<td>-XX:+ScavengeBeforeFullGC</td>
</tr>
<tr>
<td>幸存区比例不会变化的垃圾回收器</td>
<td>-XX: +UseSerialGC</td>
</tr>
<tr>
<td>串行垃圾回收器（新生代是复制算法，老年是标记整理算法）</td>
<td>-XX:+UseSerialGC= Serial + Serialold</td>
</tr>
</tbody></table>
<h3 id="解析垃圾回收信息"><a href="#解析垃圾回收信息" class="headerlink" title="解析垃圾回收信息"></a>解析垃圾回收信息</h3><p><strong>设置的虚拟机参数：</strong></p>
<p>-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:ge</p>
<p><strong>控制台信息</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220121201703726.png" alt="image-20220121201703726"></p>
<ul>
<li>new generation : 新生代  这里总容量9m的原因是因为默认认为to不可以被占用，因此就默认减去了1m<ul>
<li>eden ： 伊甸园</li>
<li>from ：幸存区的from区</li>
<li>to ： 幸存区的 to 区</li>
</ul>
</li>
<li>tenured generatioin ： 老年代</li>
<li>meta space : 元空间</li>
<li>后面的数字就是内存地址</li>
<li>默认的伊甸园占的比例是0.8</li>
</ul>
<h4 id="内存溢出在子线程会不会引起主线程结束"><a href="#内存溢出在子线程会不会引起主线程结束" class="headerlink" title="内存溢出在子线程会不会引起主线程结束"></a>内存溢出在子线程会不会引起主线程结束</h4><p>子线程的内存溢出并不会引起主线程结束</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><ul>
<li><strong>单线程</strong></li>
<li>适用于堆内存小，适合个人电脑</li>
</ul>
<p><strong>虚拟机参数</strong></p>
<p>-XX:+UseSerialGC= Serial + Serialold</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220122113807682.png" alt="image-20220122113807682"></p>
<p>所有的线程须达到安全点之后才可以执行垃圾回收</p>
<p>其他线程需要等到垃圾回收线程结束之后才可以开始继续运行</p>
<h3 id="吞吐量优先（垃圾回收时间占用总时间越少，吞吐量越高）"><a href="#吞吐量优先（垃圾回收时间占用总时间越少，吞吐量越高）" class="headerlink" title="吞吐量优先（垃圾回收时间占用总时间越少，吞吐量越高）"></a>吞吐量优先（垃圾回收时间占用总时间越少，吞吐量越高）</h3><ul>
<li>优先</li>
<li>适用于堆内存较大，多核cpu</li>
<li><strong>单位时间</strong>内stw时间最短（总体时间）</li>
</ul>
<p><strong>虚拟机配置（1.8默认的）</strong></p>
<p>并行的</p>
<p><strong>新生代的（复制算法）</strong>          <strong>老年代的（标记整理算法）</strong></p>
<p>-XX:+UseParallelGC              -XX: +UseParallelOldGC</p>
<p>开启上述其中一个，另一个会自动开启</p>
<p><strong>设置垃圾回收线程个数</strong></p>
<p>-XX: ParallelGCThreads=n</p>
<p><strong>自适应调整新生代的大小，晋升阈值也会受影响</strong></p>
<p>-XX;+UseAdaptivesizePolicy</p>
<p><strong>调整吞吐量的目标，调整垃圾回收与总时间的占比</strong></p>
<p>-XX:GCTimeRatio=ratio（垃圾回收时间比例=1/（1+ratio））</p>
<p><strong>最大暂停毫秒数，最大是200ms</strong></p>
<p>-XX:MaxGCPauseMillis=ms</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220122155817392.png" alt="image-20220122155817392"></p>
<p>也是所有线程到达安全点之后，就会开始多线程开始回收，线程个数与cpu核数有关，核数有多少，线程的上限就是多少</p>
<h3 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h3><ul>
<li>多线程</li>
<li>适用于堆内存较大，多核cpu</li>
<li>注重垃圾回收<strong>单次</strong>stop the world（stw）时间尽可能短</li>
</ul>
<p><strong>并发进行执行垃圾回收</strong></p>
<p>垃圾回收与普通线程同时进行，两类线程互相争夺时间片</p>
<p><strong>老年代</strong>  （标记清除）                                           <strong>新生代</strong></p>
<p>-XX:+UseConcMarkSweepGC   -XX:+UseParNewGC - SerialOld</p>
<p>一旦出现并发问题，老年代GC会退化为串行GC</p>
<p><strong>设置并行线程数</strong>                        <strong>设置并发线程数，建议设置为并行线程数的四分之一</strong></p>
<p>-XX :ParallelGCThreads=n     -XX:ConcGCThreads=threads</p>
<p><strong>只要老年代到达percent之后，就进行清理，是给浮动垃圾留空间</strong></p>
<p>-XX:CMSInitiating0ccupancyFraction=percent</p>
<p><strong>做重新标记之前，先把新生代做一次垃圾回收</strong></p>
<p>这里的原因是因为有新生代要回收的有很多，而且可能新生代还引用了老年代，但这些新生代本身就已经要被清除了，所以即使我们通过他们发现了一些老年代不能进行回收，但是后期这些新生代本身就要进行回收，实际上了做了无用功，因此可以提前对其进行清理，从而达到减少时间的目的</p>
<p>-XX:+CMSScavengeBeforeRemark</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220122162126627.png" alt="image-20220122162126627"></p>
<ul>
<li>初始标记只会标记根对象，此时很快，但是会引发stw</li>
<li>并发标记会标记间接或直接引用的对象，此时与用户线程并发运行</li>
<li>并发标记后会及逆行重新标记，会引起stw（因为并发标记时，标记的内容可能地址会进行改变，因此需重新标记）</li>
<li>重新标记之后会进行并发处理</li>
<li>并发清理过程中，其他线程可能又会有新垃圾（浮动垃圾），这些垃圾下次处理，因此需要专门设置浮动垃圾空间</li>
</ul>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p><img src="/hexo_blog/2022/01/21/jvm/image-20220118162509588.png" alt="image-20220118162509588"></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220118165503266.png" alt="image-20220118165503266"></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="string">&quot;123&quot;</span></span><br><span class="line">String b=<span class="string">&quot;55&quot;</span></span><br><span class="line">String c=a+b</span><br></pre></td></tr></table></figure>

<p>c的赋值其实是先调用Stringbuilder的toString方法生成一个新的String对象，然后返回给c</p>
<p>但是如下图这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="string">&quot;a&quot;</span></span><br><span class="line">String b=<span class="string">&quot;b&quot;</span></span><br><span class="line">String c=<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>;</span><br><span class="line">String d=<span class="string">&quot;ab&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时，c==d是true，因为在编译时，javac会默认认为”a”+”b”就是”ab”，因此直接调用常量池的内容就可以</p>
<h3 id="主动将字符串对象放入串池"><a href="#主动将字符串对象放入串池" class="headerlink" title="主动将字符串对象放入串池"></a>主动将字符串对象放入串池</h3><p>itern（）：将字符串对象放入串池，若不存在，则放入，否则不进行放入</p>
<h2 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p><img src="/hexo_blog/2022/01/21/jvm/image-20220121113317503.png" alt="image-20220121113317503"></p>
<p>原来的占用内存-&gt;回收后的内存，Full GC表示垃圾回收资源太少，因此采用更加强烈的垃圾回收，即软链接垃圾回收</p>
<p>初次回收时会将所有的弱引用对象引用的对象回收掉，若是回收之后内存依然不够，会对软引用在进行回收</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发：并发是指两个或多个事件在同一时间间隔发生</p>
<p>并行：并行是指两个或者多个事件在同一时刻发生。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-22T15:55:27.000Z" title="2021-10-22 23:55:27">2021-10-22</time>发表</span><span class="level-item"><time dateTime="2021-10-22T15:55:52.510Z" title="2021-10-22 23:55:52">2021-10-22</time>更新</span><span class="level-item">5 分钟读完 (大约711个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2021/10/22/%E7%8E%A9%E7%88%AC%E8%99%AB%E4%B8%8D%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93you-get%EF%BC%8C%E5%BF%AB%E8%BF%9B%E6%9D%A5%E7%9C%8B%E7%9C%8B/">玩爬虫不能不知道you-get，快进来看看</a></h1><div class="content"><p>@<a href="you-get%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">TOC</a></p>
<h1 id="什么是you-get"><a href="#什么是you-get" class="headerlink" title="什么是you-get"></a>什么是you-get</h1><p>首先咱们先从字面上分析一下，各位兄弟搬好小板凳，接下来小王利用三年级英语水平给大家翻译一下</p>
<p>首先you的意思是你，get有拿的意思，众所周知英语擅长倒装，没错连起来就是–拿来吧你<br><img src="https://img-blog.csdnimg.cn/1995c20033e0416bbf2decb4db61937f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCx5b6I5pyJ6Laj,size_10,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>引入结束，现在回归正题，其实you-get就是一个别人替我们写好的一个下载神器，可以特别方便的在网络上下载资源，具体怎么使用，咱么继续往下看。</p>
<h1 id="you-get的安装"><a href="#you-get的安装" class="headerlink" title="you-get的安装"></a>you-get的安装</h1><p>前提条件，电脑需要安装python环境，看过博主之前的爬虫文章的兄弟们相信都具备了这个条件，那么接下来就是安装you-get<br>随便打开一个cmd，输入以下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade you-get</span><br></pre></td></tr></table></figure>
<p>安装没有报错，显示内容与与下图显示大致相同，即成功<br><img src="https://img-blog.csdnimg.cn/dc8ceff6f11c48c3b6ace2c8fdce14f9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCx5b6I5pyJ6Laj,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="you-get的使用"><a href="#you-get的使用" class="headerlink" title="you-get的使用"></a>you-get的使用</h1><p>复制资源，然后在你想要存储文件的目录下打开cmd，也就是在地址栏输入cmd即可，如下图<br><img src="https://img-blog.csdnimg.cn/e8b7b01f34bd446aba52da91d71ea4f1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCx5b6I5pyJ6Laj,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在cmd中输入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get 视频链接</span><br></pre></td></tr></table></figure>
<p>如下图所示即下载成功<br><img src="https://img-blog.csdnimg.cn/97f308195606426da69cb99c7ed5c07b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCx5b6I5pyJ6Laj,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>打开下载的文件就可以使用了</p>
<p>更多高级操作大家可以在cmd中输入以下内容进行查看</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get -h</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个小工具的使用，很简单，之前文章中很多人评论，我就专门看了看，最近有时间就写成了博客，下次有缘再写</p>
<p><strong>推荐下自己的爬虫专栏，有几篇基础的爬虫文章，有兴趣的兄弟们可以看看<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/category_11148878.html">基础爬虫专栏</a></strong><br><img src="https://img-blog.csdnimg.cn/6612f96639a546b28b5617230b9b3c10.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCx5b6I5pyJ6Laj,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-24T00:32:53.000Z" title="2021-8-24 8:32:53">2021-08-24</time>发表</span><span class="level-item"><time dateTime="2021-08-24T00:33:22.419Z" title="2021-8-24 8:33:22">2021-08-24</time>更新</span><span class="level-item">8 分钟读完 (大约1246个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2021/08/24/python%E7%88%AC%E5%8F%96%E5%8D%81%E4%B8%87%E5%BC%A0%E8%A1%A8%E6%83%85%E5%8C%85/">python爬取十万张表情包</a></h1><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>事情要从几天前说起，我有一个朋友，他在和他喜欢的小姐姐聊天时，聊天的气氛一直非常尬，这时他就想发点表情包来缓和一下气氛，但一看自己的表情包收藏都是这样的。。。<br><img src="https://img-blog.csdnimg.cn/bab5094aa71d4a7a85db04ea89edfe09.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>。。。这发过去，基本就直接和小姐姐说拜拜了，然后他就向我求救问我有没有表情包，表情包我是没有，但网站有呀，来来，爬虫整起。<br><img src="https://img-blog.csdnimg.cn/a4ce1fc32fc245f794a164d938d2ff70.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="分析页面"><a href="#分析页面" class="headerlink" title="分析页面"></a>分析页面</h1><p>今天爬取的网站是<a target="_blank" rel="noopener" href="https://www.doutula.com/photo/list/">斗图吧</a>，有一说一表情包是真的多，看这惊人的页数<img src="https://img-blog.csdnimg.cn/7b0a25676b03449fab0d41dd7aabb908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70"><br>接下来就该看看怎么拿到表情包图片的url了，首先打开谷歌浏览器，然后点F12进入爬虫快乐模式<br><img src="https://img-blog.csdnimg.cn/f9526a6403084452945e2245f0b334cc.png" alt="在这里插入图片描述"><br>然后完成下图的操作，先点击1号箭头，然后再选中一个表情包即可，红色框中就是我们要爬取的对象，其中表情包的src就在里面<br><img src="https://img-blog.csdnimg.cn/c4db6eba149f4be189ca9fda21557a41.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在我们就搞清楚了怎么拿到表情包的url了，就开始写代码了</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="解析页面"><a href="#解析页面" class="headerlink" title="解析页面"></a>解析页面</h2><h3 id="获取网页内容"><a href="#获取网页内容" class="headerlink" title="获取网页内容"></a>获取网页内容</h3><p>这里就是获取爬取网页的信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">askURL</span>(<span class="params">url</span>):</span></span><br><span class="line">    head = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.106 Safari/537.36&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    req = urllib.request.Request(url=url, headers=head)</span><br><span class="line">    html = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = urllib.request.urlopen(req)</span><br><span class="line">        html = response.read()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="keyword">return</span> html</span><br></pre></td></tr></table></figure>
<h3 id="解析网页内容"><a href="#解析网页内容" class="headerlink" title="解析网页内容"></a>解析网页内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取出图片src的正则式</span></span><br><span class="line">imglink = re.<span class="built_in">compile</span>(</span><br><span class="line">    <span class="string">r&#x27;&lt;img alt=&quot;(.*?)&quot; class=&quot;img-responsive lazy image_dta&quot; data-backup=&quot;.*?&quot; data-original=&quot;(.*?)&quot; referrerpolicy=&quot;no-referrer&quot; src=&quot;.*?&quot;/&gt;&#x27;</span>,</span><br><span class="line">    re.S)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getimgsrcs</span>(<span class="params">url</span>):</span></span><br><span class="line">    html = askURL(url)</span><br><span class="line">    bs = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    names = []</span><br><span class="line">    srcs = []</span><br><span class="line">    <span class="comment"># 找到所有的img标签</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> bs.find_all(<span class="string">&#x27;img&#x27;</span>):</span><br><span class="line">        item = <span class="built_in">str</span>(item)</span><br><span class="line">        <span class="comment"># 根据上面的正则表达式规则把图片的src以及图片名拿下来</span></span><br><span class="line">        imgsrc = re.findall(imglink, item)</span><br><span class="line">        <span class="comment"># 这里是因为拿取的img标签可能不是我们想要的，所以匹配正则规则之后可能返回空值，因此判断一下</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(imgsrc) != <span class="number">0</span>):</span><br><span class="line">            imgname = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> imgsrc[<span class="number">0</span>][<span class="number">0</span>] != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                imgname = imgsrc[<span class="number">0</span>][<span class="number">0</span>] + <span class="string">&#x27;.&#x27;</span> + getFileType(imgsrc[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                imgname = getFileName(imgsrc[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">            names.append(imgname)</span><br><span class="line">            srcs.append(imgsrc[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> names, srcs</span><br></pre></td></tr></table></figure>
<p>到现在为止，已经拿到了所有的图片的链接和名字，那么就可以开始下载了</p>
<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><h3 id="多线程下载"><a href="#多线程下载" class="headerlink" title="多线程下载"></a>多线程下载</h3><p>因为文件实在有点多，所以最好采用多线程的方式下载，我这里只是给了一个样例，大家按照这个逻辑写一下就好</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool = ThreadPoolExecutor(max_workers=<span class="number">50</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(names)):</span><br><span class="line">           pool.submit(FileDownload.downloadFile, urls[j], filelocation[j])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><p><img src="https://img-blog.csdnimg.cn/8929ca48245746dc80c5f806d9b299e9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/d7339c08d7884a5ca79fb5f9b1b98f69.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总共是爬了十万多张表情包，这次咱也是表情包大户了<br><img src="https://img-blog.csdnimg.cn/fe0f759c1b7b4d06852469408416c3f8.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>很简单的一个爬虫，适合我这样的初学者练练手，如果对爬虫有兴趣的话可以看看我的爬虫专栏的其他文章，说不定也有你喜欢的</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/category_11148878.html">爬虫专栏，快来点我呀</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/article/details/119799493">两行代码爬取微博热搜，并实现邮件提醒功能，妈妈再也不用担心我吃不到瓜了 爬虫基础</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/article/details/118662227">python爬取4k小姐姐图片 人生苦短 我用python
</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/article/details/118517916">python爬b站视频 人生苦短 我用python</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/article/details/118077285">Python爬取美女图片 爬虫基础</a></p>
<p>有缘再写，侵权立删</p>
<p><img src="https://img-blog.csdnimg.cn/64ad1d642f274dcd80775b52498a39c3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-20T04:59:01.000Z" title="2021-8-20 12:59:01">2021-08-20</time>发表</span><span class="level-item"><time dateTime="2021-08-20T04:59:35.344Z" title="2021-8-20 12:59:35">2021-08-20</time>更新</span><span class="level-item"><a class="link-muted" href="/hexo_blog/categories/python/">python</a></span><span class="level-item">14 分钟读完 (大约2029个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2021/08/20/ts%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD/">ts视频下载</a></h1><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前一直爬取的内容都是完整的文件，例如一整个mp3或则mp4，但是目前很多视频网站都开始采用ts流媒体视频的方式进行视频的展示，不知道你有没有这样的体验，兴致勃勃的打开一个电影网站，准备开始施展爬虫大法<br><img src="https://img-blog.csdnimg.cn/20210719225220529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查看xhr请求之后，本以为可以找到一个返回mp4的接口，没想到返回的是这一堆ts文件<br><img src="https://img-blog.csdnimg.cn/20210719225300180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>今天我们就来聊一聊怎么下载这些ts文件并将他们拼接为一个mp4</p>
<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><p>ffmpeg，pycharm</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>首先打开谷歌浏览器，F12，查看xhr请求，这一步相信兄弟们已经轻车熟路了。如下图<br><img src="https://img-blog.csdnimg.cn/20210719230452670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>有两个诡异的m3u8，木错，这就是今天我们的突破口，一般第一个m3u8中存储的都是第二个m3u8文件的url，第二个m3u8文件则是存储的ts文件的urll。因为我们这次主要是讲怎么下载ts文件，所以直接用解析第二个m3u8文件，即可。<br>双击这个请求，就可以查看详情，其中Request URL就是调用的接口或则远程文件，直接调用则会下载该m3u8文件，然后解析一下，拿到ts的url列表就可以进行下载了。<br><img src="https://img-blog.csdnimg.cn/20210719230924707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先看一下这个m3u8文件的内容<br><img src="https://img-blog.csdnimg.cn/20210719231345962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>很明显文件中存储的不是ts文件的完整地址，需要我们根据实际情况进行拼接就可以，查看的方式就是点击ts文件xhr请求进行查看如下图，很明显，红框圈中的就是我们要拼接在文件名之前的。这就拿到了真实的ts文件地址。<br><img src="https://img-blog.csdnimg.cn/20210719231700488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么开整代码吧</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="解析m3u8文件，获取ts下载列表"><a href="#解析m3u8文件，获取ts下载列表" class="headerlink" title="解析m3u8文件，获取ts下载列表"></a>解析m3u8文件，获取ts下载列表</h2><p>要使用到m3u8这个库来解析m3u8文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> m3u8</span><br><span class="line">tss = []</span><br><span class="line">order = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#realurl就是存储ts文件地址的m3u8文件的url ，这样返回的数据是json格式的，方便读取数据</span></span><br><span class="line">data = m3u8.load(realurl).data</span><br><span class="line"></span><br><span class="line"><span class="comment"># appendurl就是要拼接在前面的那个地址 这样存入tss的ts文件地址都是真实地址</span></span><br><span class="line"><span class="comment"># order的作用是在将多个ts文件合成一个mp4时，由这个order提供各ts文件拼接的顺序</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data[<span class="string">&quot;segments&quot;</span>]:</span><br><span class="line">        tss.append(appendurl + <span class="string">&quot;/&quot;</span> + i[<span class="string">&quot;uri&quot;</span>])</span><br><span class="line">        order.append(i[<span class="string">&quot;uri&quot;</span>])</span><br></pre></td></tr></table></figure>


<p>到现在为止，ts文件拼接的顺序以及ts文件的真实地址就全部拿到了</p>
<h2 id="多线程下载ts文件，以及ts文件顺序的存储"><a href="#多线程下载ts文件，以及ts文件顺序的存储" class="headerlink" title="多线程下载ts文件，以及ts文件顺序的存储"></a>多线程下载ts文件，以及ts文件顺序的存储</h2><p>有一说一，这些ts文件不仅多，而且小，如果我们只是一个线程下载文件，未免太浪费时间了，而且效率太低了，这次我们采用多线程的方式进行大量ts文件的下载</p>
<h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">url, name</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#记录创立的线程</span></span><br><span class="line">    task_list = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取ts的真实地址和顺序</span></span><br><span class="line">    tss, order = getTss(url)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这里将ts文件顺序存储在m3u8，至于为啥这么做，因为ts文件数量太多了</span></span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&quot;E://file//order.m3u8&quot;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这里将下载ts文件的本地路径输入到order.m3u8之中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> order:</span><br><span class="line">        file.write(<span class="string">f&quot;file &#x27;E:\\file\\ts\\&quot;</span> + i + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        file.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#线程池的创立 </span></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=<span class="number">50</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(order)):</span><br><span class="line">        <span class="comment"># 启动多个线程下载文件</span></span><br><span class="line">        task_list.append(pool.submit(FileDownload.downloadFile, <span class="string">&#x27;E://file//ts//&#x27;</span> + order[i], tss[i]))</span><br><span class="line">    <span class="comment"># 判断所有下载线程是否全部结束</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(task_list) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> task_list:</span><br><span class="line">            <span class="keyword">if</span> i.done():</span><br><span class="line">                task_list.remove(i)</span><br><span class="line">    <span class="comment"># 进行多个ts文件的合并</span></span><br><span class="line">    VideoUtil.mixTss(name)</span><br><span class="line">    <span class="comment"># 合并结束之后把ts文件都删了，不然太占空间了</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> order:</span><br><span class="line">        turl = <span class="string">f&quot;E:\\file\\ts\\&quot;</span> + u</span><br><span class="line">        os.remove(turl)</span><br></pre></td></tr></table></figure>

<h3 id="ts文件顺序存储到本地文件中"><a href="#ts文件顺序存储到本地文件中" class="headerlink" title="ts文件顺序存储到本地文件中"></a>ts文件顺序存储到本地文件中</h3><p><strong>主要代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里将下载ts文件的本地路径输入到order.m3u8之中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> order:</span><br><span class="line">        file.write(<span class="string">f&quot;file &#x27;E:\\file\\ts\\&quot;</span> + i + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        file.write(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>最终文件中存储的内容<br><img src="https://img-blog.csdnimg.cn/20210719233457729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最好按照这种格式存入，之前在网上找的其他格式都会报错，但这个是ok的</p>
<h3 id="多线程下载ts文件"><a href="#多线程下载ts文件" class="headerlink" title="多线程下载ts文件"></a>多线程下载ts文件</h3><p>yysy，多线程真的强，尤其是下载这些小文件，多线程真的是绝了</p>
<p>本文采用线程池的方式，为什么采用线程池呢，因为线程池可以帮我们保留一段时间空闲线程，可以减少线程创建和销毁所耗费的时间，大大提高多线程的效率，同时可以帮助我们限制线程的数量<br><strong>主要代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#线程池的创立 </span></span><br><span class="line">  pool = ThreadPoolExecutor(max_workers=<span class="number">50</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(order)):</span><br><span class="line">      <span class="comment"># 启动多个线程下载文件</span></span><br><span class="line">      task_list.append(pool.submit(FileDownload.downloadFile, <span class="string">&#x27;E://file//ts//&#x27;</span> + order[i], tss[i]))</span><br><span class="line">  <span class="comment"># 判断所有下载线程是否全部结束</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(task_list) == <span class="number">0</span>:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> task_list:</span><br><span class="line">          <span class="keyword">if</span> i.done():</span><br><span class="line">              task_list.remove(i)</span><br></pre></td></tr></table></figure>

<h2 id="ts文件合成mp4"><a href="#ts文件合成mp4" class="headerlink" title="ts文件合成mp4"></a>ts文件合成mp4</h2><p>主要思路就是利用刚刚生成的那个ts顺序文件（order.m3u8），按照文件中的顺序进行ts文件的拼接。</p>
<p>这里拼接ts文件时还是要使用ffmpeg，没有的兄弟们可以看下这个安装一下<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/article/details/118584645">ffmpeg安装教程</a><br><strong>主要代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mixTss</span>(<span class="params">name</span>):</span></span><br><span class="line">    com = <span class="string">r&#x27;D:\\tool\\ffmpeg\\bin\\ffmpeg.exe -f concat -safe 0 -i E:\\file\\order.m3u8 -c copy E:\\file\\video2\\&#123;&#125;.mp4&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        name)</span><br><span class="line">    os.system(com)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里解释一下<br><strong>D:\tool\ffmpeg\bin\ffmpeg.exe</strong>  ：  本地ffmpeg的位置，设置了环境变量直接ffmpeg即可</p>
<p><strong>E:\file\order.m3u8</strong>：刚刚生成的存储ts文件的顺序的文件路径</p>
<p><strong>E:\file\video2\{}.mp4</strong>：视频最终合成之后存放的位置</p>
<p>至此，ts视频的下载以及合成一个mp4就实现了</p>
<h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><h2 id="ts文件"><a href="#ts文件" class="headerlink" title="ts文件"></a>ts文件</h2><p>这是下载过程中截的图，有一说一，看着这些文件爆炸式增加，还挺爽<br><img src="https://img-blog.csdnimg.cn/20210719234816694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="mp4文件"><a href="#mp4文件" class="headerlink" title="mp4文件"></a>mp4文件</h2><p><img src="https://img-blog.csdnimg.cn/20210719235046784.png" alt="在这里插入图片描述"><br>具体就不给你们康了，你们猜猜是啥<br><img src="https://img-blog.csdnimg.cn/20210719235238912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之没有想象的这么难，做之前以为很复杂，其实还好，最后欢迎各位大佬指点。<br><img src="https://img-blog.csdnimg.cn/20210719235440164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-20T04:57:49.000Z" title="2021-8-20 12:57:49">2021-08-20</time>发表</span><span class="level-item"><time dateTime="2021-08-20T04:58:24.265Z" title="2021-8-20 12:58:24">2021-08-20</time>更新</span><span class="level-item"><a class="link-muted" href="/hexo_blog/categories/%E7%88%AC%E8%99%AB/">爬虫</a></span><span class="level-item">10 分钟读完 (大约1469个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2021/08/20/Python%E7%88%AC%E5%8F%96%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87/">Python爬取美女图片</a></h1><div class="content"><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>作为一个考研狗，每天除了日复一日的复习外，偶尔也想给自己寻找一些生活的小乐趣，今天突然想到了自己曾经稍微接触的爬虫，想看看可以爬取些图片放到电脑上，就花了些时间改了改之前的爬虫代码，爬取了一部分照片先量一下战绩吧。照片不多但也算是自己的一次爬虫小经验。<br><img src="https://img-blog.csdnimg.cn/20210620234909406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210620234923201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>爬虫的网页很简单，照片真实路径都在页面中直接可以拿到<br>主要流程就是先进入照片浏览的主页，每个照片的主页都会链接几个照片页面，像下面这样，每个图片都会链接一个网页<br><img src="https://img-blog.csdnimg.cn/20210621000150492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">图片链接的网页如下图所示<br><img src="https://img-blog.csdnimg.cn/20210621000255924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是这个页面显示的图片还是不够高清，这个网站有一个规律，更高清的照片存放的网页就在现在这个页面的路径后跟一个  -1920x1080  的htm中，进入这个htm之后展示的照片才是我们要的，拿到图片的url就直接下载就好，就这样一直循环，所有的照片就都下载下来了。</p>
<h1 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h1><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadFile</span>(<span class="params">name, url</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        headers = &#123;<span class="string">&#x27;Proxy-Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>&#125;</span><br><span class="line">        r = requests.get(url, stream=<span class="literal">True</span>, headers=headers)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=========================&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(r)</span><br><span class="line">        length = <span class="built_in">float</span>(r.headers[<span class="string">&#x27;Content-length&#x27;</span>])</span><br><span class="line">        f = <span class="built_in">open</span>(name, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        count_tmp = <span class="number">0</span></span><br><span class="line">        time1 = time.time()</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">512</span>):</span><br><span class="line">            <span class="keyword">if</span> chunk:</span><br><span class="line">                f.write(chunk)  <span class="comment"># 写入文件</span></span><br><span class="line">                count += <span class="built_in">len</span>(chunk)  <span class="comment"># 累加长度</span></span><br><span class="line">                <span class="comment"># 计算时间 两秒打印一次</span></span><br><span class="line">                <span class="keyword">if</span> time.time() - time1 &gt; <span class="number">2</span>:</span><br><span class="line">                    p = count / length * <span class="number">100</span></span><br><span class="line">                    speed = (count - count_tmp) / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">2</span></span><br><span class="line">                    count_tmp = count</span><br><span class="line">                    <span class="built_in">print</span>(name + <span class="string">&#x27;: &#x27;</span> + formatFloat(p) + <span class="string">&#x27;%&#x27;</span> + <span class="string">&#x27; Speed: &#x27;</span> + formatFloat(speed) + <span class="string">&#x27;M/S&#x27;</span>)</span><br><span class="line">                    time1 = time.time()</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;出现异常&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">formatFloat</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    downloadFile(<span class="string">&#x27;D://file//photo//hd.jpg&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;https://browser9.qhimg.com/bdr/__85/t01753453b660de14e9.jpg&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>文件下载没什么好说的，复制就可以用，这里做了一个异常捕获的处理，因为可能出现连接不上资源，或则目标服务器强制关闭连接的可能，做这个异常处理就是为了判断有没有异常出现，从而进行相应的处理</p>
<h2 id="爬虫代码"><a href="#爬虫代码" class="headerlink" title="爬虫代码"></a>爬虫代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- codeing = utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2021/6/19 23:01</span></span><br><span class="line"><span class="comment"># @Author : xiaow</span></span><br><span class="line"><span class="comment"># @File : PhotoSpider.py</span></span><br><span class="line"><span class="comment"># @Software : PyCharm</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  <span class="comment"># 网页解析</span></span><br><span class="line"><span class="keyword">import</span> xlwt  <span class="comment"># excel操作</span></span><br><span class="line"><span class="keyword">import</span> sqlite3  <span class="comment"># 数据库操作</span></span><br><span class="line"><span class="keyword">from</span> api <span class="keyword">import</span> spider2 <span class="keyword">as</span> spider</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> api <span class="keyword">import</span> FileDownload <span class="keyword">as</span> fd</span><br><span class="line"><span class="keyword">import</span> re  <span class="comment"># 正则表达式</span></span><br><span class="line"></span><br><span class="line">imglink = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;a href=&quot;(.*?)&quot; target=&quot;_blank&quot; title=&quot;.*?&quot;&gt;&lt;img alt=&quot;.*?&quot; src=&quot;.*?&quot;/&gt;&lt;b&gt;.*?&lt;/b&gt;&lt;/a&gt;&#x27;</span>, re.S)</span><br><span class="line">img2link = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;a href=&quot;(.*?)&quot; target=&quot;_blank&quot;&gt;.*?&lt;span&gt;（1680x1050）&lt;/span&gt;&lt;/a&gt;&#x27;</span>, re.S)</span><br><span class="line">img3link = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;img alt=&quot;.*?&quot; src=&quot;(.*?)&quot; title=&quot;.*?&quot;/&gt;&#x27;</span>, re.S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取照片页面路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPhoto</span>(<span class="params">url</span>):</span></span><br><span class="line">    srcs = []</span><br><span class="line">    html = spider.askURL(url);</span><br><span class="line">    bs = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> bs.find_all(<span class="string">&#x27;a&#x27;</span>, target=<span class="string">&quot;_blank&quot;</span>):</span><br><span class="line">        item = <span class="built_in">str</span>(item)</span><br><span class="line">        src = re.findall(imglink, item)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(src) != <span class="number">0</span>):</span><br><span class="line">            srcs.append(<span class="string">&quot;http://www.netbian.com&quot;</span> + src[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> srcs;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 照片主页显示的照片不够清楚，这里根据这个网站存储照片的规律，拼接了一个地址，这个地址的照片比较高清一些</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPhotoUrl</span>(<span class="params">url</span>):</span></span><br><span class="line">    purls = [];</span><br><span class="line">    url3 = <span class="string">&quot;http://www&quot;</span>;</span><br><span class="line">    url2 = url.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(url2)):</span><br><span class="line">        <span class="keyword">if</span> j == <span class="built_in">len</span>(url2) - <span class="number">2</span>:</span><br><span class="line">            url3 = url3 + <span class="string">&quot;.&quot;</span> + url2[j] + <span class="string">&quot;-1920x1080&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            url3 = url3 + <span class="string">&quot;.&quot;</span> + url2[j]</span><br><span class="line">    <span class="keyword">return</span> (url3)</span><br><span class="line"><span class="comment"># 下载照片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadPhoto</span>(<span class="params">url</span>):</span></span><br><span class="line">    html = spider.askURL(url);</span><br><span class="line">    bs = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> bs.find_all(<span class="string">&quot;img&quot;</span>):</span><br><span class="line">        item=<span class="built_in">str</span>(item)</span><br><span class="line">        itemsrc=re.findall(img3link,item)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span>(itemsrc)!=<span class="number">0</span>):</span><br><span class="line">           <span class="keyword">return</span> itemsrc[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src = <span class="string">&quot;http://www.netbian.com/mei/index_&quot;</span>;</span><br><span class="line">    <span class="comment"># 拼接照片主页的路径</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">163</span>):</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        src2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        src2=src+<span class="built_in">str</span>(i)+<span class="string">&quot;.htm&quot;</span></span><br><span class="line">        urls=getPhoto(src2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(urls)):</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            fd.downloadFile(<span class="string">&#x27;D://file//photo//hd&#x27;</span>+<span class="built_in">str</span>(time.time())+<span class="string">&quot;.jpg&quot;</span>,downloadPhoto(getPhotoUrl(urls[j])))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><p>展示几张照片吧<br><img src="https://img-blog.csdnimg.cn/20210620235958613.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210621000008150.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210621000017216.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>解析网页的封装类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- codeing = utf-8 -*-</span></span><br><span class="line"><span class="comment">#@Time : 2021/3/1 16:16</span></span><br><span class="line"><span class="comment">#@Author : xiaow</span></span><br><span class="line"><span class="comment">#@File : spider2.py</span></span><br><span class="line"><span class="comment">#@Software : PyCharm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re  <span class="comment"># 正则表达式</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib.request, urllib.error  <span class="comment"># 指定url，获取网页数据</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  <span class="comment"># 网页解析</span></span><br><span class="line"><span class="keyword">import</span> xlwt  <span class="comment"># excel操作</span></span><br><span class="line"><span class="keyword">import</span> sqlite3  <span class="comment"># 数据库操作</span></span><br><span class="line"></span><br><span class="line">baseurl = <span class="string">&#x27;https://movie.douban.com/top250?start=&#x27;</span></span><br><span class="line"></span><br><span class="line">imglink = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;a href=&quot;.*?&quot; title=&quot;.*?&quot;&gt;&#x27;</span>, re.S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># titlelink = re.compile(r&#x27;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&#x27;)</span></span><br><span class="line"><span class="comment"># findlink = re.compile(r&#x27;&lt;a href=&quot;(.*?)&quot;&gt;&#x27;)  # 创建正则表达式 表示规则</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.爬取网页</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span>(<span class="params">url</span>):</span></span><br><span class="line">    urllist = []</span><br><span class="line">    valuelist = []</span><br><span class="line">    <span class="comment"># 2.解析数据</span></span><br><span class="line">    img = []</span><br><span class="line">    src = []</span><br><span class="line">    title = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        url = baseurl + <span class="built_in">str</span>(i * <span class="number">25</span>)</span><br><span class="line">        html = askURL(url)</span><br><span class="line">        bs = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(bs)</span><br><span class="line">        <span class="comment"># urllist.append(bs.a.attrs[&quot;href&quot;])</span></span><br><span class="line">        <span class="comment"># valuelist.append(bs.a.string)</span></span><br><span class="line">        <span class="comment"># return urllist, valuelist</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> bs.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&quot;item&quot;</span>):  <span class="comment"># 查找div 并且该div应满足class=item</span></span><br><span class="line">            <span class="comment"># print(item)</span></span><br><span class="line">            item = <span class="built_in">str</span>(item)</span><br><span class="line">            <span class="comment"># titlel = re.findall(titlelink, item)</span></span><br><span class="line">            <span class="comment"># title.append(titlel)</span></span><br><span class="line">            <span class="comment"># srcl = re.findall(findlink, item)  # 正则表达式进行筛选</span></span><br><span class="line">            <span class="comment"># for s in srcl:</span></span><br><span class="line">            <span class="comment">#     src.append(s)</span></span><br><span class="line">            imgl = re.findall(imglink, item)  <span class="comment"># 正则表达式进行筛选</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> imgl:</span><br><span class="line">                img.append(i)</span><br><span class="line">    <span class="keyword">return</span> title, img, src;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到一个url的网页内容1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">askURL</span>(<span class="params">url</span>):</span></span><br><span class="line">    head = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.106 Safari/537.36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Cookie&quot;</span>: <span class="string">&#x27;_ga=GA1.2.1191993538.1623990557; _gid=GA1.2.176559558.1623990557; HstCfa3699098=1623990557028; HstCmu3699098=1623990557028; HstCnv3699098=1; HstCns3699098=1; newurl=0; __dtsu=10401623990557D693AE61F09F524965; pbnfgecookieinforecord=%2C64-32128%2C64-32129%2C; HstCla3699098=1623991353818; HstPn3699098=7; HstPt3699098=7&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    req = urllib.request.Request(url=url, headers=head)</span><br><span class="line">    html = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = urllib.request.urlopen(req)</span><br><span class="line">        html = response.read()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.保存数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">savaData</span>(<span class="params">savepath</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-20T04:38:07.000Z" title="2021-8-20 12:38:07">2021-08-20</time>发表</span><span class="level-item"><time dateTime="2021-08-20T04:44:09.341Z" title="2021-8-20 12:44:09">2021-08-20</time>更新</span><span class="level-item"><a class="link-muted" href="/hexo_blog/categories/%E7%88%AC%E8%99%AB/">爬虫</a></span><span class="level-item">8 分钟读完 (大约1252个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2021/08/20/python%E7%88%AC%E5%8F%96b%E7%AB%99%E8%A7%86%E9%A2%91/">python爬取b站视频</a></h1><div class="content"><p>[TOC]</p>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>不知道兄弟们有没有遇到过b站视频经常下架的问题，就比如我现在想在b站找一个老师的课程，运气好可以找到，但经常看了一段时间之后可能就会下架，然后继续找，过不了多久又会下架，这样的循环搞得我好烦呀，这时候我突然想起来万能的python，python爬b站视频咋样？说干就干<br><img src="https://img-blog.csdnimg.cn/20210706122749463.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>python环境必不可少，同时需要ffmpeg，一台可以上网的电脑</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先随便打开一个视频，然后右键查看网页源代码<br><img src="https://img-blog.csdnimg.cn/20210706123120628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于展示的源代码格式有点乱，所以我选择复制到vscode中查看<br><img src="https://img-blog.csdnimg.cn/20210706123351383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这时候看着就舒服多了，细心的朋友可能已经发现baseUrl，然后我们复制一下这个baseUrl，在浏览器中打开康康，果然不出所料<br><img src="https://img-blog.csdnimg.cn/20210706123513743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>还是老实巴交的用python访问吧，header头设置好之后就可以直接访问了，至于header头怎么设置，相信兄弟们都懂，一切就绪之后可以拿到这个文件，值得注意的是b站的视频文件和音频文件是分开存储的，因此我们还需要下载音频文件，音频文件url的位置和视频文件url的位置靠很近，就在audio这里存放着<br><img src="https://img-blog.csdnimg.cn/20210706123935767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这样音频文件和视频文件的地址我么都拿到了，随后就可以开始下载了，下载之后使用ffmpeg将两个文件操作一下就可以了。这里有ffmpeg的安装教程，大家可以看一下，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/article/details/118584645">ffmpeg安装教程</a>，欢迎三连</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="音频和视频整合的工具类"><a href="#音频和视频整合的工具类" class="headerlink" title="音频和视频整合的工具类"></a>音频和视频整合的工具类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声音视频结合</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">videoMixAudio</span>(<span class="params">videourl, audiourl, mp4url</span>):</span></span><br><span class="line">    com = <span class="string">f&#x27;D:\\tool\\ffmpeg\\bin\\ffmpeg.exe -i &quot;<span class="subst">&#123;audiourl&#125;</span>&quot; -i &quot;<span class="subst">&#123;videourl&#125;</span>&quot; &#x27;</span> \</span><br><span class="line">          <span class="string">f&#x27;-acodec copy -vcodec copy &quot;<span class="subst">&#123;mp4url&#125;</span>&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line">    os.system(com)</span><br><span class="line">    os.remove(videourl)</span><br><span class="line">    os.remove(audiourl)</span><br></pre></td></tr></table></figure>
<p>这里解释一下。videourl是视频文件的全路径，audiourl是音频文件的全路径，mp4url则是生成的有声音的视频的位置，然后通过调用ffmpeg来对音频和视频文件进行合成，没有使用ffmpeg的同学们可以采用格式工厂的方式对这两个文件操作进行操作也是可以的。</p>
<h2 id="分析页面"><a href="#分析页面" class="headerlink" title="分析页面"></a>分析页面</h2><p>使用到了这三个匹配规则</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拿到&lt;script&gt;中的内容</span></span><br><span class="line">valink = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;script&gt;(.*?)&lt;/script&gt;&#x27;</span>)</span><br><span class="line"><span class="comment"># 拿到window.__playinfo__后面的内容</span></span><br><span class="line">infoink = re.<span class="built_in">compile</span>(<span class="string">r&#x27;window.__playinfo__=(.*)&#x27;</span>)</span><br><span class="line"><span class="comment"># 这个是为了拿到视频的名字 可以选择不用</span></span><br><span class="line">nameink = re.<span class="built_in">compile</span>(<span class="string">r&#x27;window.__INITIAL_STATE__=(.*);\(function&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>valink用于取出下图这个部分的内容<br><img src="https://img-blog.csdnimg.cn/20210706125139973.png" alt="在这里插入图片描述"><br>infoink是为了把window._playinfo_去掉，这样拿到的就是可以转换为json的字符串<br>这样就可以拿到视频和音频的url了<br><strong>代码如下</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadVideo</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 获取网页源代码</span></span><br><span class="line">    html = requests.get(url).text</span><br><span class="line">    <span class="comment"># 拿到script的内容</span></span><br><span class="line">    info = re.findall(valink, html)</span><br><span class="line">    <span class="comment"># 第一个就是playinfo的那个script</span></span><br><span class="line">    info2 = <span class="built_in">str</span>(info[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 这一个是存放视频信息的scripte</span></span><br><span class="line">    info3 = <span class="built_in">str</span>(info[<span class="number">1</span>])</span><br><span class="line">    nameAnd=re.findall(nameink,info3)</span><br><span class="line">    <span class="comment"># 把window._playinfo_去掉，拿到一个可以转换为json的字符串</span></span><br><span class="line">    videoAndAudio = re.findall(infoink, info2)</span><br><span class="line">    <span class="comment"># str转json</span></span><br><span class="line">    jsonobject = json.loads(videoAndAudio[<span class="number">0</span>])</span><br><span class="line">    nameobject = json.loads(nameAnd[<span class="number">0</span>])</span><br><span class="line">    name=nameobject[<span class="string">&quot;videoData&quot;</span>][<span class="string">&quot;title&quot;</span>]</span><br><span class="line">    <span class="comment"># 获取视频和音频的链接</span></span><br><span class="line">    videoFile = jsonobject[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;dash&quot;</span>][<span class="string">&quot;video&quot;</span>][<span class="number">0</span>][<span class="string">&quot;baseUrl&quot;</span>]</span><br><span class="line">    audioFile = jsonobject[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;dash&quot;</span>][<span class="string">&quot;audio&quot;</span>][<span class="number">0</span>][<span class="string">&quot;baseUrl&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>拿到链接之后就可以开始下载了，记住下载的时候要设置好header</p>
<h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><p><img src="https://img-blog.csdnimg.cn/2021070613001556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>全部代码就不贴了，兄弟们按照这个流程就可以实现，过程还是比较简单的，自己用用就好。希望和大家一起进步<img src="https://img-blog.csdnimg.cn/20210706130616161.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-19T10:46:54.000Z" title="2021-8-19 18:46:54">2021-08-19</time>发表</span><span class="level-item"><time dateTime="2021-08-19T11:09:13.973Z" title="2021-8-19 19:09:13">2021-08-19</time>更新</span><span class="level-item"><a class="link-muted" href="/hexo_blog/categories/java/">java</a></span><span class="level-item">16 分钟读完 (大约2372个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2021/08/19/Harmony%E5%BC%80%E5%8F%91%E6%A0%B7%E4%BE%8B/">Harmony开发样例</a></h1><div class="content"><p>@[TOC](开发一个可以看小姐姐照片的鸿蒙应用 鸿蒙开发入门)</p>
<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p>先整张效果图，丑点是丑点，但可以用，买不起鸿蒙系统手机的我，只配用虚拟机。</p>
<p><img src="https://img-blog.csdnimg.cn/57347fae3c3a422db48bdd062329f991.gif" alt="在这里插入图片描述"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>要说目前最火的手机操作系统，要我来看的话那必然是鸿蒙无疑。16号刚刚结束了第五次鸿蒙内测，在看到这次的内测名单之后，居然有970的机器，这是不是说明俺这手里奋战了三年的荣耀play也可以生鸿蒙了，但现实是970三孤儿果然名不虚传，还是没有我们。<br><img src="https://img-blog.csdnimg.cn/a83d1ad8fba1487486cfc369c687caad.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>那么言归正传，这次突然想做一个基于鸿蒙的小demo，然后又想到了我之前爬取的小姐姐图片链接还没有用武之地，这俩是不是可以结合一下？上次有这样的想法还是上一次，那么就做一个看小姐姐的小demo吧，开整开整。<br><img src="https://img-blog.csdnimg.cn/4c3b2d8e96e6471996cb838f816f8688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>之前在网上看到有直接把图片下载下来然后放进项目中的，这个很明显不适合我，不仅占的空间大，而且图片还得手动更新，这可不行</p>
<p>我们采用的是调用图片链接接口获取所有的图片链接，一个链接只是一个字符串要比图片占的空间小太多了，将这些链接存储在内存中，有兴趣的可以存在数据库里，然后每次随机获取一条链接就可以，由这条链接获取图片信息，将图片渲染到页面就可以。</p>
<p>整个流程简单的一塌糊涂，总结一下就是</p>
<ul>
<li>拿取图片链接</li>
<li>由链接获取图片信息</li>
<li>渲染至显示页面</li>
</ul>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h2><p>这个比较基础了，就不说了，如果不大了解的兄弟们，直接去官方文档看看就可以，建立流程非常简单。</p>
<h2 id="建立http链接拿取图片链接"><a href="#建立http链接拿取图片链接" class="headerlink" title="建立http链接拿取图片链接"></a>建立http链接拿取图片链接</h2><h3 id="设置网络权限"><a href="#设置网络权限" class="headerlink" title="设置网络权限"></a>设置网络权限</h3><p>我们需要访问网络，就必须要设置网络权限，来到config.json文件中，添加以下内容</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;reqPermissions&quot;</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ohos.permission.INTERNET&quot;</span></span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;com.wxr.xiaowpic.DataAbilityShellProvider.PROVIDER&quot;</span></span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ohos.permission.GET_NETWORK_INFO&quot;</span></span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ohos.permission.SET_NETWORK_INFO&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure>
<p>直接在module中添加如上内容，如下图<br><img src="https://img-blog.csdnimg.cn/c5669a3fcbd34388b97ad3338400972c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="设置允许http请求"><a href="#设置允许http请求" class="headerlink" title="设置允许http请求"></a>设置允许http请求</h3><p>这里注意，重点哈，鸿蒙默认的是发起https请求，因此如果我们发起http请求是会报错的，这里需要修改一下<br>还是在config.json下，在deviceConfig中添加以下内容</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;default&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;network&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cleartextTraffic&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如下图所示，这里吐槽一下，我再寻找怎么设置允许发起http响应的时候，发现好多文章都一样，而且都不适用于我这个项目，还有的人复制别人的文章也能复制错，绝了。<br><img src="https://img-blog.csdnimg.cn/ba89f39960ac4d92ad076c8b3a2c3e8a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="发起http请求，并获取返回的数据"><a href="#发起http请求，并获取返回的数据" class="headerlink" title="发起http请求，并获取返回的数据"></a>发起http请求，并获取返回的数据</h3><h4 id="json数据解析"><a href="#json数据解析" class="headerlink" title="json数据解析"></a>json数据解析</h4><p>这里要使用到alibaba的fastjson工具类，在build.gradle引入如下依赖</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="keyword">group</span>: <span class="string">&#x27;com.alibaba&#x27;</span>, name: <span class="string">&#x27;fastjson&#x27;</span>, version: <span class="string">&#x27;1.2.73&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如下图所示<br><img src="https://img-blog.csdnimg.cn/6d585bcd58bb47e4824c9d5b016fa9b7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="发起请求，获得响应内容"><a href="#发起请求，获得响应内容" class="headerlink" title="发起请求，获得响应内容"></a>发起请求，获得响应内容</h4><p>这里使用的是大佬封装好的专门用于请求接口的一个工具，ZZRHttp，同样需要引入依赖，引入过程和上面fastjson引入过程一致。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.zzrv5.zzrhttp:ZZRHttp:1.0.1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>获取接口数据的具体实现如下，这里解释一下，<a target="_blank" rel="noopener" href="https://2fd8e89d.cpolar.io/getAll%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%98%AF%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E7%9A%84%EF%BC%8C%E6%98%AF%E6%88%91%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%89%80%E4%BB%A5%E5%A4%A7%E5%AE%B6%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%88%91%E5%8F%AF%E4%BB%A5%E6%8A%8A%E6%88%91%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%8F%91%E7%BB%99%E4%BD%A0%E4%BB%AC%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%AD%98%E5%82%A8%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%82">https://2fd8e89d.cpolar.io/getAll这个接口地址，是获取图片链接的，是我本地的服务，所以大家如果需要的话，我可以把我的服务代码发给你们，包括存储图片链接的数据库。</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ZZRHttp.get(<span class="string">&quot;https://2fd8e89d.cpolar.io/getAll&quot;</span>, <span class="keyword">new</span> ZZRCallBack.CallBackString() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> code, String errorMessage)</span> </span>&#123;</span><br><span class="line">                      <span class="comment">//http访问出错，此部分在主线程中工作,可以更新UI等操做。</span></span><br><span class="line">                      MyLabel.error(<span class="string">&quot;访问图片链接接口出错&quot;</span>);</span><br><span class="line">                      <span class="keyword">new</span> ToastDialog(getContext()).setText(<span class="string">&quot;网络连接出问题了，请稍后重试&quot;</span>).show();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">                      <span class="comment">//http访问成功，此部分在主线程中工作，可以更新UI等操作。</span></span><br><span class="line">                      MyLabel.info(<span class="string">&quot;获取图片链接成功&quot;</span>);</span><br><span class="line">                      <span class="keyword">new</span> ToastDialog(getContext()).setText(<span class="string">&quot;正在初始化，稍后&quot;</span>).show();</span><br><span class="line">                      <span class="comment">//将字符串转换为json对象</span></span><br><span class="line">                      JSONObject jsonObject = JSONObject.parseObject(response);</span><br><span class="line">                      <span class="comment">//将其中返回的图片链接转换为列表</span></span><br><span class="line">                      JSONArray info = (JSONArray) jsonObject.get(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">                      MyLabel.info(<span class="string">&quot;拿取数据量：&quot;</span> + info.size());</span><br><span class="line">                      info.forEach(item -&gt; &#123;</span><br><span class="line">                          srcs.add(item.toString());</span><br><span class="line">                      &#125;);</span><br><span class="line">                      <span class="keyword">new</span> ToastDialog(getContext()).setText(<span class="string">&quot;初始化成功，开始你的快乐吧&quot;</span>).show();</span><br><span class="line">                      MyLabel.info(<span class="string">&quot;内存中数据数量&quot;</span> + srcs.size());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="将获取的图片链接放入内存中"><a href="#将获取的图片链接放入内存中" class="headerlink" title="将获取的图片链接放入内存中"></a>将获取的图片链接放入内存中</h3><p>就是声明一个静态列表变量，目的是为了下次获取图片链接时可以直接在这里拿取图片链接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PicDao picDao = <span class="keyword">new</span> PicDaoImpl(getContext());</span><br><span class="line">        <span class="comment">//使用后台线程进行初始化</span></span><br><span class="line">        TaskDispatcher refreshUITask = createParallelTaskDispatcher(<span class="string">&quot;&quot;</span>, TaskPriority.DEFAULT);</span><br><span class="line">        refreshUITask.syncDispatch(() -&gt; &#123;</span><br><span class="line"><span class="comment">//            List&lt;PicSrc&gt; list = picDao.list();</span></span><br><span class="line">            <span class="comment">//判断内存中有无数据</span></span><br><span class="line">            <span class="keyword">if</span> (srcs.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                MyLabel.info(<span class="string">&quot;内存中没东西，第一次打开应用&quot;</span>);</span><br><span class="line">                MyLabel.info(<span class="string">&quot;调用图片接口获取图片链接列表&quot;</span>);</span><br><span class="line">                ZZRHttp.get(<span class="string">&quot;https://2fd8e89d.cpolar.io/getAll&quot;</span>, <span class="keyword">new</span> ZZRCallBack.CallBackString() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> code, String errorMessage)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//http访问出错，此部分在主线程中工作,可以更新UI等操做。</span></span><br><span class="line">                        MyLabel.error(<span class="string">&quot;访问图片链接接口出错&quot;</span>);</span><br><span class="line">                        <span class="keyword">new</span> ToastDialog(getContext()).setText(<span class="string">&quot;网络连接出问题了，请稍后重试&quot;</span>).show();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//http访问成功，此部分在主线程中工作，可以更新UI等操作。</span></span><br><span class="line">                        MyLabel.info(<span class="string">&quot;获取图片链接成功&quot;</span>);</span><br><span class="line">                        <span class="keyword">new</span> ToastDialog(getContext()).setText(<span class="string">&quot;正在初始化，稍后&quot;</span>).show();</span><br><span class="line">                        JSONObject jsonObject = JSONObject.parseObject(response);</span><br><span class="line">                        JSONArray info = (JSONArray) jsonObject.get(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">                        MyLabel.info(<span class="string">&quot;拿取数据量：&quot;</span> + info.size());</span><br><span class="line">                        info.forEach(item -&gt; &#123;</span><br><span class="line">                            srcs.add(item.toString());</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">new</span> ToastDialog(getContext()).setText(<span class="string">&quot;初始化成功，开始你的快乐吧&quot;</span>).show();</span><br><span class="line">                        MyLabel.info(<span class="string">&quot;内存中数据数量&quot;</span> + srcs.size());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                MyLabel.info(<span class="string">&quot;已经有内容了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取网络图片并展示在页面上"><a href="#获取网络图片并展示在页面上" class="headerlink" title="获取网络图片并展示在页面上"></a>获取网络图片并展示在页面上</h2><h3 id="http请求工具类"><a href="#http请求工具类" class="headerlink" title="http请求工具类"></a>http请求工具类</h3><p>这个类的主要作用就是发起http请求，并返回响应字节流，其实就是获取图片的字节流，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wxr.xiaowpic.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wxr.xiaowpic.label.MyLabel;</span><br><span class="line"><span class="keyword">import</span> com.zzrv5.mylibrary.ZZRCallBack;</span><br><span class="line"><span class="keyword">import</span> com.zzrv5.mylibrary.ZZRHttp;</span><br><span class="line"><span class="keyword">import</span> ohos.hiviewdfx.HiLog;</span><br><span class="line"><span class="keyword">import</span> ohos.utils.net.Uri;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//url就是要访问的网络资源，methodType就是请求方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputStream <span class="title">getInput</span><span class="params">(String url,String methodType)</span></span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url1=<span class="keyword">new</span> URL(url);</span><br><span class="line">            HttpURLConnection urlConnection = (HttpURLConnection) url1.openConnection();</span><br><span class="line">            urlConnection.setRequestMethod(methodType);</span><br><span class="line">            urlConnection.connect();</span><br><span class="line">            <span class="keyword">int</span> rescode=urlConnection.getResponseCode();</span><br><span class="line">            <span class="keyword">if</span>(rescode==HttpURLConnection.HTTP_OK)&#123;</span><br><span class="line">                inputStream=urlConnection.getInputStream();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            HiLog.error(MyLabel.LABEL_LOG,e.getMessage());</span><br><span class="line">            HiLog.error(MyLabel.LABEL_LOG,e.getCause().toString());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inputStream;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="字节流转图片工具类"><a href="#字节流转图片工具类" class="headerlink" title="字节流转图片工具类"></a>字节流转图片工具类</h3><p>没啥好说的，复制就可以用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wxr.xiaowpic.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wxr.xiaowpic.label.MyLabel;</span><br><span class="line"><span class="keyword">import</span> ohos.hiviewdfx.HiLog;</span><br><span class="line"><span class="keyword">import</span> ohos.hiviewdfx.HiLogLabel;</span><br><span class="line"><span class="keyword">import</span> ohos.media.image.ImageSource;</span><br><span class="line"><span class="keyword">import</span> ohos.media.image.PixelMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HiLogLabel LABEL_LOG = <span class="keyword">new</span> HiLogLabel(<span class="number">3</span>, <span class="number">0xD001100</span>, <span class="string">&quot;XiaoW&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PixelMap <span class="title">createPixelMap</span><span class="params">(String imageUrl)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取图片字节流信息</span></span><br><span class="line">        InputStream inputStream = HttpUtils.getInput(imageUrl,<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        PixelMap pixelMap=<span class="keyword">null</span>;</span><br><span class="line">        ImageSource.SourceOptions sourceOptions = <span class="keyword">new</span> ImageSource.SourceOptions();</span><br><span class="line">        sourceOptions.formatHint = <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line">        HiLog.info(MyLabel.LABEL_LOG,(inputStream==<span class="keyword">null</span>)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ImageSource imageSource = ImageSource.create(inputStream,sourceOptions);</span><br><span class="line">            pixelMap = imageSource.createPixelmap(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            HiLog.info(LABEL_LOG,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pixelMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="图片展示在页面"><a href="#图片展示在页面" class="headerlink" title="图片展示在页面"></a>图片展示在页面</h3><p>这里采用的是按钮点击之后进行图片的渲染，其中图片链接是在我们获取的图片链接随机读取一个，然后将该照片渲染至页面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">button.setClickedListener(<span class="keyword">new</span> Component.ClickedListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">               TaskDispatcher refreshUITask = createParallelTaskDispatcher(<span class="string">&quot;&quot;</span>, TaskPriority.DEFAULT);</span><br><span class="line">               refreshUITask.syncDispatch(() -&gt; &#123;</span><br><span class="line">                   <span class="comment">//在链接列表中随机取一个数据</span></span><br><span class="line">                   <span class="keyword">int</span> index = (<span class="keyword">int</span>) (Math.random() * srcs.size());</span><br><span class="line">                   MyLabel.info(srcs.get(index));</span><br><span class="line">                   String url=srcs.get(index);</span><br><span class="line">                   MyLabel.info(<span class="string">&quot;开始获取图片&quot;</span>);</span><br><span class="line">                   <span class="comment">//访问线上图片</span></span><br><span class="line">                   PixelMap pixelMap = ImageUtils.createPixelMap(url);</span><br><span class="line">                   getContext().getUITaskDispatcher().asyncDispatch(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                           <span class="comment">//Image组件填充位图数据，ui界面更新</span></span><br><span class="line">                           image.setPixelMap(pixelMap);</span><br><span class="line">                           pixelMap.release();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line"></span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>之前没有自己做过移动端的demo，总之收获还是不少的，所以期间出了不少问题，需要全部代码的兄弟们私信就好。<br><img src="https://img-blog.csdnimg.cn/8d3af6a0e56a429bbfe2ceac9ebba236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-19T10:39:58.000Z" title="2021-8-19 18:39:58">2021-08-19</time>发表</span><span class="level-item"><time dateTime="2021-08-20T04:45:27.392Z" title="2021-8-20 12:45:27">2021-08-20</time>更新</span><span class="level-item"><a class="link-muted" href="/hexo_blog/categories/%E9%9A%8F%E7%AC%94/">随笔</a></span><span class="level-item">几秒读完 (大约44个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2021/08/19/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/">个人介绍</a></h1><div class="content"><h1 id="博主介绍"><a href="#博主介绍" class="headerlink" title="博主介绍"></a>博主介绍</h1><p>XiaoW</p>
<p>下面就是我的照片，献丑了</p>
<p><img src="/hexo_blog/2021/08/19/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/123.jpg" alt="123"></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>该个人博客展示的博客多来自我个人的csdn博客</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/hexo_blog/page/3/">上一页</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/hexo_blog/page/5/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/hexo_blog/">1</a></li><li><a class="pagination-link" href="/hexo_blog/page/2/">2</a></li><li><a class="pagination-link" href="/hexo_blog/page/3/">3</a></li><li><a class="pagination-link is-current" href="/hexo_blog/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/hexo_blog/img/123.jpg" alt="XiaoW"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">XiaoW</p><p class="is-size-6 is-block">keep coding keep go on</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>山东</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/hexo_blog/archives"><p class="title">39</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/hexo_blog/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/hexo_blog/tags"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gitee.com/xiaow123" target="_blank" rel="noopener">关注我</a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://gitee.com/xiaow123" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/qq_43627076" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">csdn</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/hexo_blog/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/categories/%E7%88%AC%E8%99%AB/"><span class="level-start"><span class="level-item">爬虫</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/categories/%E9%9A%8F%E7%AC%94/"><span class="level-start"><span class="level-item">随笔</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-03T07:58:51.000Z">2022-12-03</time></p><p class="title"><a href="/hexo_blog/2022/12/03/rabbitmq/">rabbitmq</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-28T14:49:37.847Z">2022-11-28</time></p><p class="title"><a href="/hexo_blog/2022/11/28/%E6%9C%BA%E5%99%A8%E4%BA%BA/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-17T11:41:25.000Z">2022-11-17</time></p><p class="title"><a href="/hexo_blog/2022/11/17/diffusion/">diffusion</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-14T07:57:19.000Z">2022-11-14</time></p><p class="title"><a href="/hexo_blog/2022/11/14/RFN-Nest/">RFN-Nest</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-29T02:58:08.000Z">2022-10-29</time></p><p class="title"><a href="/hexo_blog/2022/10/29/%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/">自监督学习</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/hexo_blog/archives/2022/12/"><span class="level-start"><span class="level-item">十二月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2022/11/"><span class="level-start"><span class="level-item">十一月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2022/09/"><span class="level-start"><span class="level-item">九月 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/Harmony/"><span class="tag">Harmony</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/nginx/"><span class="tag">nginx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"><span class="tag">人工智能</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E5%AE%89%E5%85%A8/"><span class="tag">安全</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">深度学习</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E7%88%AC%E8%99%AB/"><span class="tag">爬虫</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"><span class="tag">神经网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"><span class="tag">论文阅读</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><span class="tag">论文阅读笔记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E9%9A%8F%E7%AC%94/"><span class="tag">随笔</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/hexo_blog/"><img src="/hexo_blog/img/logo.svg" alt="xiaow的博客" height="28"></a><p class="is-size-7"><span>&copy; 2023 xiaow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/hexo_blog/js/column.js"></script><script src="/hexo_blog/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/hexo_blog/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/hexo_blog/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/hexo_blog/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/hexo_blog/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>