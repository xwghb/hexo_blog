<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>xiaow的博客</title><link rel="manifest" href="/hexo_blog/manifest.json"><meta name="application-name" content="xiaow的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="xiaow的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="个人技术博客"><meta property="og:type" content="blog"><meta property="og:title" content="xiaow的博客"><meta property="og:url" content="https://xiaow123.gitee.io/hexo_blog"><meta property="og:site_name" content="xiaow的博客"><meta property="og:description" content="个人技术博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/img/og_image.png"><meta property="article:author" content="xiaow"><meta property="article:tag" content="java,python"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/hexo_blog/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaow123.gitee.io/hexo_blog"},"headline":"xiaow的博客","image":["https://xiaow123.gitee.io/hexo_blog/img/og_image.png"],"author":{"@type":"Person","name":"xiaow"},"publisher":{"@type":"Organization","name":"xiaow的博客","logo":{"@type":"ImageObject","url":"https://xiaow123.gitee.io/img/logo.svg"}},"description":"个人技术博客"}</script><link rel="icon" href="/hexo_blog/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/hexo_blog/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/hexo_blog/"><img src="/hexo_blog/img/logo.svg" alt="xiaow的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/hexo_blog/">主页</a><a class="navbar-item" href="/hexo_blog/archives">归档</a><a class="navbar-item" href="/hexo_blog/categories">分类</a><a class="navbar-item" href="/hexo_blog/tags">标签</a><a class="navbar-item" href="https://xiaow123.gitee.io/staicpage/html/mine/">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-09T08:51:20.000Z" title="2022-4-9 16:51:20">2022-04-09</time>发表</span><span class="level-item"><time dateTime="2022-04-10T07:08:58.146Z" title="2022-4-10 15:08:58">2022-04-10</time>更新</span><span class="level-item">5 分钟读完 (大约719个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2022/04/09/FastDFS/">FastDFS</a></h1><div class="content"><h1 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h1><p><img src="/hexo_blog/2022/04/09/FastDFS/image-20220402113411887.png" alt="image-20220402113411887"></p>
<p>分布式文件系统得系统结构如上图</p>
<p>升级之后</p>
<p><img src="/hexo_blog/2022/04/09/FastDFS/image-20220402135549480.png" alt="image-20220402135549480"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>功能有文件存储，文件同步，文件访问等</p>
<h2 id="centos环境配置"><a href="#centos环境配置" class="headerlink" title="centos环境配置"></a>centos环境配置</h2><p>linux所需的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install lrzsz wget vim unzip net-tools -y</span><br></pre></td></tr></table></figure>

<p>nginx与fdfs所需的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc perl openssl openssl-devel pcre pcre-devel zlib zlib-devel libevent libevent-devel -y </span><br></pre></td></tr></table></figure>

<h2 id="centos命令"><a href="#centos命令" class="headerlink" title="centos命令"></a>centos命令</h2><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state	</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>

<h3 id="更换yum源"><a href="#更换yum源" class="headerlink" title="更换yum源"></a>更换yum源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">mkdir bak</span><br><span class="line">mv * bak/</span><br><span class="line">wget https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo -O /etc/yum.repos.d/Centos-vault-8.5.2111.repo</span><br><span class="line">wget https://mirrors.aliyun.com/repo/epel-archive-8.repo -O /etc/yum.repos.d/epel-archive-8.repo</span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br></pre></td></tr></table></figure>



<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>由客户端与服务端组成</p>
<p>FastDFS提供了API访问</p>
<p>两个节点     跟踪器（tracker）和存储器（storage）</p>
<p>跟踪器主要负责调度工作，记录集群中storage节点的信息，是前端与后端存储结点的枢纽</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>linux安装环境</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc libevent libevent-devel -y</span><br></pre></td></tr></table></figure>

<ul>
<li>安装公共函数库 (文件在D;/tool/fastDFS中)<ul>
<li>上传文件 rz -y</li>
<li>解压common压缩包  （unzip）     </li>
<li>运行make.sh     <strong>(./make.sh)</strong>    编译</li>
<li>安装   ./make.sh  install</li>
<li>按照以上顺序在安装fastDFS master</li>
</ul>
</li>
</ul>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>修改配置文件 </p>
<p>tracker.conf 修改base_path ,就是修改存放日志的位置</p>
<p>storage.conf 修改</p>
<p>base_path = /opt/fastdfs/storage</p>
<p>tracker_server = 192.168.183.128:22122</p>
<p>store_path0 = /opt/fastdfs/storage/files</p>
<p><strong>修改之后把所有的文件都移到/etc/fdfs中</strong></p>
<p><strong>启动storage</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdfs_storaged /etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure>

<p><strong>启动tracker</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdfs_trackerd /etc/fdfs/tracker.conf</span><br></pre></td></tr></table></figure>

<h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><p><strong>上传文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdfs_test /etc/fdfs/client.conf upload a.txt</span><br></pre></td></tr></table></figure>



<p><strong>下载文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdfs_test /etc/fdfs/client.conf download group1 M00/00/00/wKi3gGJKVyWALaJRAAAAE_-IeRQ599.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>删除文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdfs_test /etc/fdfs/client.conf delete group1 M00/00/00/wKi3gGJKVyWALaJRAAAAE_-IeRQ599.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p><strong>引入压缩包</strong></p>
<p>压缩包为<strong>fastdfs-nginx-module-master.zip</strong></p>
<p><strong>下载nginx</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.6.2.tar.gz </span><br></pre></td></tr></table></figure>

<p><strong>解压</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.6.2.tar.gz</span><br></pre></td></tr></table></figure>



<p><strong>配置nginx</strong></p>
<p>来到nginx的解压目录，配置nginx</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/nginx_fdfs --add-module=/mydata/fastdfs/fastdfs-nginx-module-master/src</span><br></pre></td></tr></table></figure>

<p>然后依次执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install	</span><br></pre></td></tr></table></figure>



<p>将扩展的conf文件复制到/etc/fdfs下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mod_fastdfs.conf /etc/fdfs</span><br></pre></td></tr></table></figure>



<p><strong>配置mode_fastdfs.conf (fastdfs-nginx-module-master扩展模块解压之后的src中)</strong></p>
<p>配置basepath</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base_path=/opt/fdfs/nginx_mod</span><br></pre></td></tr></table></figure>

<p>配置trackerserver</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tracker_server=192.168.183.128:22122</span><br><span class="line">url_have_group_name = <span class="literal">true</span></span><br><span class="line">store_path0=/opt/fdfs/storage/files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将conf文件移动到/etc/fdfs中</p>
<p><strong>配置nginx（/usr/local/nginx_fdfs/conf/nginx.conf）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ /group[1-9]/M0[0-9] &#123;</span><br><span class="line">             ngx_fastdfs_module;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx_fdfs/sbin/nginx -c /usr/<span class="built_in">local</span>/nginx_fdfs/conf/nginx.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="tracker的nginx配置"><a href="#tracker的nginx配置" class="headerlink" title="tracker的nginx配置"></a>tracker的nginx配置</h2><p>不需要配置fdfs模块</p>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/nginx_fdfs</span><br></pre></td></tr></table></figure>

<p>来到nginx的conf，这里只做上传的nginx负载均衡</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location ~ /group[1-9]/M0[0-9] &#123;</span><br><span class="line">                proxy_pass http://fastdfs_group_server;</span><br><span class="line">       &#125;</span><br><span class="line">这个放在server外       </span><br><span class="line">upstream fastdfs_group_server&#123;</span><br><span class="line">    server socket 1;</span><br><span class="line">    server socket 2;</span><br><span class="line">    server socket 3;</span><br><span class="line">    server socket 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="storage配置nginx"><a href="#storage配置nginx" class="headerlink" title="storage配置nginx"></a>storage配置nginx</h2><p>其他的与上文一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group_count=2</span><br></pre></td></tr></table></figure>



<p>配置一下group的配置</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-12T13:37:53.000Z" title="2022-2-12 21:37:53">2022-02-12</time>发表</span><span class="level-item"><time dateTime="2022-02-19T08:59:09.190Z" title="2022-2-19 16:59:09">2022-02-19</time>更新</span><span class="level-item">8 分钟读完 (大约1228个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2022/02/12/juc/">juc</a></h1><div class="content"><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p><img src="/hexo_blog/2022/02/12/juc/image-20220212220225601.png" alt="image-20220212220225601"></p>
<p><img src="/hexo_blog/2022/02/12/juc/image-20220212220529133.png" alt="image-20220212220529133"></p>
<h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p><strong>并行（parrallel）</strong>：真正同时运行多个任务</p>
<p><strong>并发（current）</strong>：同一时间应对多个任务，处理多个任务是轮流的，实际上还是串行的，每个进程<strong>轮流占据时间片</strong>，使用cpu，时间片很小，人对此无感</p>
<p>一般都是既有并行又有并发</p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><ul>
<li>需要等待结果返回再进行，同步</li>
<li>不需要等待结果返回再进行，异步</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/hexo_blog/2022/02/12/juc/image-20220214111211433.png" alt="image-20220214111211433"></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li>Thread</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Runable配合Thread</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           log.debug(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   Thread thread=<span class="keyword">new</span> Thread(runnable,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">   thread.start();</span><br></pre></td></tr></table></figure>

<ul>
<li>lamda表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<ul>
<li>FutureTask配合Thread</li>
</ul>
<p>可以返回任务的执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FutureTask futureTask=<span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;right&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread thread=<span class="keyword">new</span> Thread(futureTask,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(futureTask.get());</span><br></pre></td></tr></table></figure>

<p>这里call可以返回结果</p>
<p>get则是获取该结果，这个过程中，该线程是阻塞的，一直到返回结果之后</p>
<h3 id="Thread与runable的关系"><a href="#Thread与runable的关系" class="headerlink" title="Thread与runable的关系"></a>Thread与runable的关系</h3><p>二者最终还是走thread的run方法</p>
<p><img src="/hexo_blog/2022/02/12/juc/image-20220215121413043.png" alt="image-20220215121413043"></p>
<p>推荐使用runable，这样可以与线程池配合</p>
<h3 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h3><ul>
<li>windows</li>
</ul>
<p>​     tasklist查看进程</p>
<p>​     taskkill 杀死进程          taskkill  /F /PID 进程id</p>
<ul>
<li>linux</li>
</ul>
<p>​       ps -fe       列出所有的运行进程信息</p>
<p>​       ps -fe | grep java 根据java关键字查找所有的进程</p>
<p>​       kill 进程号</p>
<p>​       top   动态的方式查看进程的信息</p>
<p>​       top -H  -p  进程id   查看所有的线程信息</p>
<ul>
<li>java</li>
</ul>
<p>​      jps   查看进程</p>
<p>​      jstack 进程号     该进程的所有线程</p>
<h3 id="查看线程的工具"><a href="#查看线程的工具" class="headerlink" title="查看线程的工具"></a>查看线程的工具</h3><ul>
<li><p>jconsole</p>
<p>直接win + R 输入jconsole就可以进入jconsole工具中。</p>
</li>
</ul>
<h3 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h3><p>每个线程启动后，会分配一个栈，每次方法调用又会生成一个栈帧，线程私有的，因此是线程安全的</p>
<p><img src="/hexo_blog/2022/02/12/juc/image-20220218163810518.png" alt="image-20220218163810518"></p>
<p>栈帧的结构如上</p>
<h3 id="线程上下文切换（Context-Switch）"><a href="#线程上下文切换（Context-Switch）" class="headerlink" title="线程上下文切换（Context Switch）"></a>线程上下文切换（Context Switch）</h3><p>就是线程切换另一线程运行的过程</p>
<ul>
<li>时间片使用结束</li>
<li>垃圾回收时</li>
<li>更高优先级线程需要运行</li>
<li>线程自己调用了sleep，yield，wait，join，park，synchronized，lock等方法</li>
</ul>
<p>切换时，操作系统需要保存线程的状态，并恢复另一进程的状态，对应的就是程序计数器，作用就是记住下一条jvm指令的执行地址，线程私有的</p>
<p><img src="/hexo_blog/2022/02/12/juc/image-20220218165233636.png" alt="image-20220218165233636"></p>
<p>线程数过多也不好，一旦超过内核数，就会导致线程切换</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>start（） 启动一个新线程，至于是否运行由任务调度器决定，只可以调用一次start，不可重复调用</p>
<p>run（）   线程运行时执行的操作</p>
<p>join（）   等待线程结束   进入阻塞状态</p>
<p>join(Long d) 设置最大等待时间  </p>
<p>setPriority（int grade） 设置优先级   </p>
<p>getState（） 获取线程的状态</p>
<p>isInterupted（） 判断线程是否被打断</p>
<p>isAlive（）判断线程是否存活</p>
<p>interupt（） 打断线程</p>
<p>currentThread（） 获取当前正在执行的线程</p>
<p>yield（） 提示线程调度器让出该线程对cpu的占用</p>
<p>sleep（long n） 线程睡一会    进入阻塞状态</p>
<h4 id="start与run"><a href="#start与run" class="headerlink" title="start与run"></a>start与run</h4><p>不可以由主线程直接调用run，这样就相当于主线程去跑run了</p>
<p>不能调用两次start，只可以调用一次</p>
<h4 id="sleep与yield"><a href="#sleep与yield" class="headerlink" title="sleep与yield"></a>sleep与yield</h4><p><img src="/hexo_blog/2022/02/12/juc/image-20220218170626624.png" alt="image-20220218170626624"></p>
<h4 id="setPriority（int-grade）-设置优先级"><a href="#setPriority（int-grade）-设置优先级" class="headerlink" title="setPriority（int grade） 设置优先级"></a>setPriority（int grade） 设置优先级</h4><p>数字越大，优先级越高</p>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，主线程就需要等待thread结束之后才可以继续进行</p>
<p>join（long n） n为最多等待时间</p>
<h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><p>打断sleep，wait，join的线程</p>
<p><strong>打断阻塞的线程</strong></p>
<p>抛出被打断的异常，并且停止运行</p>
<p>但是当被打断时，线程的打断状态会被置为真，可以通过该种方式停止线程</p>
<p><strong>打断运行中的线程</strong></p>
<p>并不会结束线程</p>
<p>但是当被打断时，线程的打断状态会被置为真，可以通过该种方式停止线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.interrupted()</span><br></pre></td></tr></table></figure>



<p><strong>两阶段终止模式</strong></p>
<p>在一个线程中优雅的停止另一个线程</p>
<p><img src="/hexo_blog/2022/02/12/juc/image-20220219160241895.png" alt="image-20220219160241895"></p>
<p> 整个过程其实就是，在中断时，给被中断线程一段时间来处理一下需要处理的内容</p>
<p><img src="/hexo_blog/2022/02/12/juc/image-20220219161728147.png" alt="image-20220219161728147"></p>
<h3 id="防止cpu占用100"><a href="#防止cpu占用100" class="headerlink" title="防止cpu占用100%"></a>防止cpu占用100%</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>经常睡眠一下就可以</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-12T12:09:33.000Z" title="2022-2-12 20:09:33">2022-02-12</time>发表</span><span class="level-item"><time dateTime="2022-02-13T10:22:09.451Z" title="2022-2-13 18:22:09">2022-02-13</time>更新</span><span class="level-item">10 分钟读完 (大约1553个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/">jvm续集2</a></h1><div class="content"><h1 id="jvm续集2"><a href="#jvm续集2" class="headerlink" title="jvm续集2"></a>jvm续集2</h1><h2 id="java内存模型（JMM）"><a href="#java内存模型（JMM）" class="headerlink" title="java内存模型（JMM）"></a>java内存模型（JMM）</h2><p>JMM定义了一套多线程读写共享数据时，对数据的可见性，有序性和原子性的规则与保障。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>对于i++，字节码如下</p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220212200516694.png" alt="image-20220212200516694"></p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220212200202542.png" alt="image-20220212200202542"></p>
<p>共享的数据，例如静态变量，都是存放在主内存中，线程在使用静态变量时，现需要在主内存中取出数据，在线程内存中进数据的操作，然后操作结束之后在放入主内存中</p>
<p>在单线程下是没有问题的，但是在多线程下会出现多个线程的指令交错的情况出现，这就导致了A线程首先取出了数据，但是时间片到了，这时B线程再取出数据，二者相加再放入之后，只进行了一次加一，结果只是加一，并非加二。</p>
<h4 id="如何保证原子性"><a href="#如何保证原子性" class="headerlink" title="如何保证原子性"></a><strong>如何保证原子性</strong></h4><p>对对象进行加锁，从而保证原子性，其他线程需该部分进行完，才可以对加锁对象加锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (对象)&#123;</span><br><span class="line">    原子操作代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式实现安全的i++</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Object o=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="synchronized也可以保证可见性"><a href="#synchronized也可以保证可见性" class="headerlink" title="synchronized也可以保证可见性"></a>synchronized也可以保证可见性</h4><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (run) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        run=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述代码，尽管run在主线程中已经修改为false，但是由于在十秒之后，jvm做了优化，使得不再在主内存中取出run的值，而是将run存放在高速缓存中，从而使得主线程修改的run，并没有更新到高速缓存中，如下图</p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220212211755941.png" alt="image-20220212211755941"></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>volatile<strong>修饰变量</strong></p>
<p>使得程序必须在主内存中获取值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> run=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (run) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        run=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>只可以解决可见性，不可解决原子性，适用与一个写，多个读</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>因为会出现指令重排，可能会出现我们意向不到的结果</p>
<p>设置对象为volatile，可以阻止指令重排</p>
<p>同一线程下，不影响结果时，会进行调整</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                if(instance==null)&#123;</span><br><span class="line">                    instance=new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述代码，就可能出现指令重排问题，观察字节码</p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213111616997.png" alt="image-20220213111616997"></p>
<p>在instance=new Singleton();这里，一旦系统认为21与24这两条命令执行顺序没差，进行指令重排时，就会导致先进行了24，此时instance已经非空对象，其他线程就可能直接返回instance，但此时的instance还未初始化结束</p>
<h3 id="happen-before"><a href="#happen-before" class="headerlink" title="happen-before"></a>happen-before</h3><p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213112303175.png" alt="image-20220213112303175"></p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213112339600.png" alt="image-20220213112339600"></p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213112412317.png" alt="image-20220213112412317"></p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213112500673.png" alt="image-20220213112500673"></p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213112617483.png" alt="image-20220213112617483"></p>
<p>这个意思就是t2线程截断了t1线程，并修改了x值，此时外部是可以获取到x的最新值</p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213112714274.png" alt="image-20220213112714274"></p>
<h3 id="CAS与原子类"><a href="#CAS与原子类" class="headerlink" title="CAS与原子类"></a>CAS与原子类</h3><p>CAS体现乐观锁的思想</p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213112918761.png" alt="image-20220213112918761"></p>
<p>上述代码的思想就是，将变量值先取出，修改之后，比较旧值与现在的值是否是我们期望的，若是则退出循环，否则继续循环</p>
<p>获取过程中，可由volatile对变量进行修饰，这样乐观锁适用于竞争不激烈，<strong>多核cpu</strong>的场景下</p>
<ul>
<li>未采用synchronized，因此不会出现线程阻塞</li>
<li>竞争激烈，会进行多次重试，此时效率会受到影响</li>
</ul>
<h4 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h4><p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213114110427.png" alt="image-20220213114110427"></p>
<h4 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h4><p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213114920969.png" alt="image-20220213114920969"></p>
<h4 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h4><p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213115030041.png" alt="image-20220213115030041"></p>
<p>使用案列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AtomicInteger integer=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            integer.getAndIncrement();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            integer.getAndDecrement();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(integer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="sychronized优化"><a href="#sychronized优化" class="headerlink" title="sychronized优化"></a>sychronized优化</h4><p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213115524749.png" alt="image-20220213115524749"></p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>有多线程访问，且各线程都是依次进行加锁，并没有竞争，就可以采用轻量级锁</p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213121119815.png" alt="image-20220213121119815"></p>
<p>每个线程的栈帧都包含一个锁记录的结构，内部可以存储锁定对象的mark word</p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213121424003.png" alt="image-20220213121424003"></p>
<p>这个过程当被锁对象中保存了线程锁记录地址之后，才被认为枷锁成功，若失败可升级为重量级锁</p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213121651776.png" alt="image-20220213121651776"></p>
<p>此时线程1有进行加锁，但是该对象已经被加锁，加锁失败，但是由于发现是自己加的锁，所以执行锁重入即可</p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213121809320.png" alt="image-20220213121809320"></p>
<h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213121937942.png" alt="image-20220213121937942"></p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213122000879.png" alt="image-20220213122000879"></p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213122018616.png" alt="image-20220213122018616"></p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213122229094.png" alt="image-20220213122229094"></p>
<p>以上可以认为</p>
<ul>
<li>线程1对对象加锁，此时还是轻量级锁</li>
<li>线程2想要对对象加锁，却发现已经被锁住了，此时就会将锁标记修改为重量级锁，并且保留重量锁指针（目的是为了唤醒阻塞的线程），此时线程二就处于阻塞中</li>
<li>待线程1解锁时，会失败，但会释放重量锁，唤起阻塞线程竞争</li>
</ul>
<h5 id="重量锁自旋"><a href="#重量锁自旋" class="headerlink" title="重量锁自旋"></a>重量锁自旋</h5><p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213125404750.png" alt="image-20220213125404750"></p>
<p>自旋其实就是线程不阻塞，反而是重试加锁，这样就省去了阻塞到唤醒的上下文切换</p>
<p>当然也会有自旋失败，即自旋多次后仍无法加锁，就阻塞</p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213125658407.png" alt="image-20220213125658407"></p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213135017128.png" alt="image-20220213135017128"></p>
<h5 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h5><p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213135505143.png" alt="image-20220213135505143"></p>
<p><img src="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/image-20220213135809599.png" alt="image-20220213135809599"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-07T04:02:58.000Z" title="2022-2-7 12:02:58">2022-02-07</time>发表</span><span class="level-item"><time dateTime="2022-03-13T14:17:36.224Z" title="2022-3-13 22:17:36">2022-03-13</time>更新</span><span class="level-item">几秒读完 (大约111个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2022/02/07/%E8%A7%86%E9%A2%91%E5%88%92%E5%88%86%E4%B8%BAts%E7%89%87%E6%AE%B5/">视频划分为ts片段</a></h1><div class="content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -y -i ***.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb ***.ts</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i ***.ts -c copy -map 0 -f segment -segment_list ***.m3u8 -segment_time 15 15s_%3d.ts</span><br></pre></td></tr></table></figure>

<p>以上两步就可以将视频划分为ts，并生成m3u8文件</p>
<p>linux方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/software/ffmpeg-5.0-amd64-static/ffmpeg -y -i   *.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb *.ts</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/software/ffmpeg-5.0-amd64-static/ffmpeg -i ***.ts -c copy -map 0 -f segment -segment_list ***.m3u8 -segment_time 15 15s_%3d.ts</span><br></pre></td></tr></table></figure>







<p>后台启动服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar  tiangou-0.0.1-SNAPSHO.jar &gt;tiangou.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-01-22T08:51:20.000Z" title="2022-1-22 16:51:20">2022-01-22</time>发表</span><span class="level-item"><time dateTime="2022-02-12T13:37:38.746Z" title="2022-2-12 21:37:38">2022-02-12</time>更新</span><span class="level-item">38 分钟读完 (大约5643个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/">jvm续集</a></h1><div class="content"><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="G1（garbage-first）垃圾回收器"><a href="#G1（garbage-first）垃圾回收器" class="headerlink" title="G1（garbage first）垃圾回收器"></a>G1（garbage first）垃圾回收器</h2><ul>
<li>同步注重吞吐量和地言辞，默认暂停目标是200ms</li>
<li>超大堆内存，会将堆划分为多个大小相同的Region，每个region可独立为老年代+新生代，划分多个region有利于加快速度</li>
<li>整体上是标记+整理算法，两个region之间是复制算法</li>
<li>g1在堆内存越来越大时，优势越大</li>
</ul>
<p>-XX:+UseG1GC    使用G1垃圾回收器（JDK9之后默认为G1）</p>
<h3 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220122165806077.png" alt="image-20220122165806077"></p>
<p>YC–》YC+CM–》MC</p>
<p><strong>三者是循环进行的</strong></p>
<h4 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h4><p>下图为多个region，最开始为空，E代表伊甸园，最开始对象分配到伊甸园区</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220122170128118.png" alt="image-20220122170128118"></p>
<p>E区占满之后会进行minor gc，将幸村对象存放在幸存区</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123100635232.png" alt="image-20220123100635232"></p>
<p>当幸存区空间不足时，会将寿命达到阈值的移动到老年去，而那些未到年龄的则到新的幸存区</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123100948952.png" alt="image-20220123100948952"></p>
<h4 id="Young-Collection-CM-concurrent-mark"><a href="#Young-Collection-CM-concurrent-mark" class="headerlink" title="Young Collection + CM(concurrent mark)"></a>Young Collection + CM(concurrent mark)</h4><ul>
<li><p>YOUNG GC进行初始标记</p>
</li>
<li><p>老年代占用空间比例到达阈值时，会进行并发标记（不会stw），阈值可由下面的参数决定         -XX: InitiatingHeapOccupancyPercent=percent（默认45%）</p>
<p>o为老年区</p>
</li>
</ul>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123101456335.png" alt="image-20220123101456335"></p>
<h4 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h4><ul>
<li>对E，S，O三个区进行整体的回收</li>
<li>E中对象分配到S中，S中年龄达到阈值的会晋升到老年区</li>
<li>在整理o区时，系统会选择进行回收之后，可以拿出更多空间的o区，进行回收，将其中非垃圾的复制到另一个o中，<strong>从而实现在最大时间下可以完成这些垃圾回收</strong>  </li>
<li>会进行最终标记，会stw</li>
<li>进行拷贝存活，会stw</li>
</ul>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123101707678.png" alt="image-20220123101707678"></p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><ul>
<li><p>SerialGC</p>
<ul>
<li>新生代内存不足发生的垃圾收集- minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
</li>
<li><p>ParallelGc</p>
<ul>
<li>新生代内存不足发生的垃圾收集- minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
</li>
<li><p>CMS</p>
<ul>
<li>新生代内存不足发生的垃圾收集- minor gc</li>
<li>老年代内存不足</li>
</ul>
</li>
<li><p>G1</p>
<ul>
<li>新生代内存不足发生的垃圾收集- minor gc</li>
<li>老年代内存不足<ul>
<li>内存比例达到阈值(默认45%)，就会出发第二阶段和第三阶段回收</li>
<li>如果这两个阶段回收速度可以赶上产生垃圾的速度，就不需要发生full gc</li>
<li>若赶不上就会开始串行收集，导致stw</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="新生代垃圾回收的跨代引用"><a href="#新生代垃圾回收的跨代引用" class="headerlink" title="新生代垃圾回收的跨代引用"></a>新生代垃圾回收的跨代引用</h3><p>根对象有一部分是来自老年代，新生代回收在进行标记时会需要查找这些根对象来进行判断那些需要回收，即垃圾，这时对老年代中所有对象进行扫描，有些耗费时间，这时就开始采用<strong>卡表</strong>的方式来对那些老年代中可做根对象的区域进行标记，称为<strong>脏卡</strong>,这时在进行回收时，直接扫描脏卡区域就可以，从而减小扫描范围，提高速度。</p>
<p><strong>这里为了方便，老年区会划分为多个区域，方便来对脏卡的标记。</strong></p>
<p>这里E区中也有<strong>Remember Set</strong>记录有哪些脏卡来引用当前E中的对象。</p>
<p>当引用变化时会及时更新脏卡，这里更新是一个异步过程，放在一个队列中进行处理</p>
<p>concurrent refinement threads更新 Remembered Set</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123171646379.png" alt="image-20220123171646379"></p>
<h3 id="Remark（重新标记阶段）"><a href="#Remark（重新标记阶段）" class="headerlink" title="Remark（重新标记阶段）"></a>Remark（重新标记阶段）</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123172913086.png" alt="image-20220123172913086"></p>
<ul>
<li>黑色已经处理完成，灰色尚在处理，白色未被处理</li>
<li>处理结束之后，黑色代表不是垃圾，白色是垃圾</li>
</ul>
<h4 id="为什么重新标记"><a href="#为什么重新标记" class="headerlink" title="为什么重新标记"></a>为什么重新标记</h4><p>因为在标记阶段是并发进行的，这时我们已经检测完A对象为垃圾，需要进行回收，但此时B对象作为不可回收的对象，有引用了A对象，此时A不应回收，但是我们已经标记A为可回收，此时就出现了错误，因此需要remark来对其进行重新标记</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>如果检测到在并发标记过程中，某对象的引用发生了变化，就需要对其进行<strong>写屏障</strong>，并将该对象放在队列中，在重新标记时对队列中的对象进行处理，重新对其进行标记。</p>
<h3 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h3><ul>
<li>jdk8中是用char数组来存放String对象</li>
<li>将所有新分配的字符串放入一个队列中</li>
<li>新生代回收时，G1并发检查是否有字符串重复</li>
<li>若值相同，则俩者引用同一个char数组</li>
<li>与串池的区别<ul>
<li>串池关注的是String对象</li>
<li>字符串关注的是char[]</li>
<li>二者在jvm内部使用不同的字符串表</li>
</ul>
</li>
<li>默认开启，模拟机参数为   -XX:+UseStringDeduplication（默认启用）</li>
<li>略微占用了cpu时间，回收时间稍长，但是总体性能有所提高</li>
</ul>
<h3 id="并发标记类卸载"><a href="#并发标记类卸载" class="headerlink" title="并发标记类卸载"></a>并发标记类卸载</h3><p>-XX:+ClassUnloadinglwithConcurrentMark 默认启用</p>
<p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类</p>
<h3 id="回收巨型对象"><a href="#回收巨型对象" class="headerlink" title="回收巨型对象"></a>回收巨型对象</h3><ul>
<li>一个对象大于一个region的一半，成为巨型对象</li>
<li>G1不会拷贝巨型对象</li>
<li>回收优先考虑巨型对象</li>
<li>G1会跟踪老年代所有incoming引用，这样老年代 incoming引用为o的巨型对象就可以在新生代垃圾回收时处理掉（人话：如果巨型对象不被引用时，就可以在新生代进行回收，总之回收越早越好）</li>
</ul>
<h3 id="JDK-9-并发标记起始时间的调整"><a href="#JDK-9-并发标记起始时间的调整" class="headerlink" title="JDK 9 并发标记起始时间的调整"></a>JDK 9 并发标记起始时间的调整</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220123213257610.png" alt="image-20220123213257610"></p>
<h2 id="垃圾回收的调优"><a href="#垃圾回收的调优" class="headerlink" title="垃圾回收的调优"></a>垃圾回收的调优</h2><h3 id="查看使用的GC"><a href="#查看使用的GC" class="headerlink" title="查看使用的GC"></a>查看使用的GC</h3><p>java   -XX:+PrintFlagsFinal -version / findstr “GC”</p>
<h2 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h2><h3 id="最快的gc是不进行gc"><a href="#最快的gc是不进行gc" class="headerlink" title="最快的gc是不进行gc"></a>最快的gc是不进行gc</h3><ul>
<li>数据是否太多</li>
<li>数据是否表示太臃肿<ul>
<li>尽可能使用基本类型，从而减少内存使用</li>
</ul>
</li>
<li>是否存在内存泄漏</li>
</ul>
<h2 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h2><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124095420031.png" alt="image-20220124095420031"></p>
<p>TLAB是每个线程独自占有的伊甸园中的一片区域</p>
<h3 id="新生代越大越好吗"><a href="#新生代越大越好吗" class="headerlink" title="新生代越大越好吗"></a>新生代越大越好吗</h3><ul>
<li>太小，会导致可用空间太少，一旦发现空间不足，就会开始新生代回收</li>
<li>太大，会导致老年代空间较小，即使新生代很空闲，但是老年代已经不够了，此时就会触发full gc，此时浪费的时间更多</li>
<li>新生代占的大小为堆的四分之一到二分之一最好</li>
</ul>
<h3 id="幸存区的大小设置"><a href="#幸存区的大小设置" class="headerlink" title="幸存区的大小设置"></a>幸存区的大小设置</h3><ul>
<li><p>要可以保留当前活跃对象和需要晋升的对象，一旦存储不下之后，老年区也会存储需要晋升的的对象，这就导致了有些对象生存时间并不长，但是这些对象进入了老年代，就导致了他活得时间太长了</p>
</li>
<li><p>长时间存活对象尽早晋升，要设置合理的晋升阈值</p>
<p><strong>设置阈值</strong></p>
<p>-XX:MaxTenuringThreshold=threshold</p>
<p><strong>打印对象寿命信息</strong></p>
<p>-XX:+PrintTenuringDistribution</p>
</li>
</ul>
<h3 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124103224214.png" alt="image-20220124103224214"></p>
<h2 id="调优案例"><a href="#调优案例" class="headerlink" title="调优案例"></a>调优案例</h2><h3 id="gc频繁"><a href="#gc频繁" class="headerlink" title="gc频繁"></a>gc频繁</h3><p>若是minor gc过于频繁，可能原因是新生代内存设置过小，此时可能导致gc频繁，从而使得响应时间增大，同样当新生代幸存区已经无力存放幸村对象时，就会导致这些对象放置在老年区，使得有些原本在 m gc阶段就可以清理的对象，必须要到full gc时期清理，从而导致了资源的浪费</p>
<p><strong>解决方案</strong></p>
<p>增大幸存区的大小即可</p>
<h3 id="请求时期发生了full-gc，单次时间较长"><a href="#请求时期发生了full-gc，单次时间较长" class="headerlink" title="请求时期发生了full gc，单次时间较长"></a>请求时期发生了full gc，单次时间较长</h3><p>remark之前先进行新生代的回收</p>
<h3 id="老年代充裕下，发生了full-gc"><a href="#老年代充裕下，发生了full-gc" class="headerlink" title="老年代充裕下，发生了full gc"></a>老年代充裕下，发生了full gc</h3><p>1.7之前，元空间不足也会引起full gc</p>
<h2 id="类加载与字节码技术"><a href="#类加载与字节码技术" class="headerlink" title="类加载与字节码技术"></a>类加载与字节码技术</h2><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124105713457.png" alt="image-20220124105713457"></p>
<h3 id="字节码文件"><a href="#字节码文件" class="headerlink" title="字节码文件"></a>字节码文件</h3><p><strong>生成字节码文件</strong></p>
<p>javac -parameters -d . test.java</p>
<h4 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h4><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124111003865.png" alt="image-20220124111003865"></p>
<p><strong>魔数</strong></p>
<p>0-3字节，表示为class类型文件</p>
<p>ca fe ba be</p>
<p><strong>版本</strong></p>
<p>4-7字节       （16进制）00 34（52）–》jdk 8</p>
<p><strong>常量池</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124113203660.png" alt="image-20220124113203660"></p>
<p>8-9 常量池的长度， 00 23（35），表示#1-#34，#0不计入，也没有值</p>
<p><strong>而后一个字节一项</strong>，方法字节后面留有4个字节，作为方法信息</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124114348241.png" alt="image-20220124114348241"></p>
<p>这个东西，字节码是十六进制的，因此两位就是一个字节，前两位是类型，后面的内容就看情况而定</p>
<p><strong>访问标识和继承信息</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124203429617.png" alt="image-20220124203429617"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124203702217.png" alt="image-20220124203702217"></p>
<p><strong>成员变量</strong></p>
<p>以下为了更好查找类名，在常量池中存放以下信息，一一对应</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124203741911.png" alt="image-20220124203741911"></p>
<p><strong>方法信息</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124203844892.png" alt="image-20220124203844892"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124203939358.png" alt="image-20220124203939358"></p>
<p>方法属性，就像方法中的代码，就被称为code属性，代码属性</p>
<p>如上图，按顺序来</p>
<p>00 01 是访问修饰，是一个公共的方法还是其他的</p>
<p>00 07 是方法的名字</p>
<p>00 08 方法参数</p>
<p>00 01 方法属性的数量</p>
<p>00 09 常量池中对应属性</p>
<p>00 00 00 2f 27 代表后面内容的长度</p>
<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124210041225.png" alt="image-20220124210041225"></p>
<h3 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h3><p>javap -v test.class </p>
<p>-v代表详细信息</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124211310398.png" alt="image-20220124211310398"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220124210923095.png" alt="image-20220124210923095"></p>
<p>dscriptor 参数类型</p>
<p>flags 代表方法是public和static修饰的（访问修饰符）</p>
<p>stack 最大操作栈深度</p>
<p>locals 局部变量表的长度</p>
<p>args_size 参数的个数</p>
<p>前面的数字代表字节码的行号</p>
<p><strong>line 这里的行号：对应字节码中的</strong></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125104219048.png" alt="image-20220125104219048"></p>
<p>类加载器将main所在的类进行类加载</p>
<p>常量池的内容到运行时常量池（属于方法区）</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125105005284.png" alt="image-20220125105005284"></p>
<p>比较小的数字，存储在方法的字节码里，<strong>但一旦超过了Short的范围，就存储在常量池中</strong></p>
<p>方法字节码存入到方法区</p>
<p>main线程开始运行分配栈帧内存，绿色的为局部变量表，蓝色为操作数栈，分别对应上述字节码文件中的stack（数量）与locals（深度）</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125105157164.png" alt="image-20220125105157164"></p>
<p>之后执行引擎就开始执行字节码的命令</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125105647350.png" alt="image-20220125105647350"></p>
<ul>
<li><p>bipush10，将10压入操作数栈中</p>
</li>
<li><p>istore1 将操作数栈中的内容送到栈帧局部变量的1号槽位（槽位编号由左向右，由0开始）</p>
</li>
<li><p>ldc #3 取出运行时常量池中的第三项，放入操作数栈</p>
</li>
<li><p>istore 2 将操作数栈的内容放入局部变量表中2号槽位</p>
</li>
<li><p>iload_1 将局部变量表中的一号槽位的内容加载至操作数栈</p>
</li>
<li><p>iload_2 与上面同理</p>
</li>
<li><p>iadd 弹出两个变量，计算后，放入操作数栈中</p>
</li>
<li><p>getstatic #4 通过常量池的内容，来获取堆中out对象的引用，将该对象引用（地址）放入至操作数中</p>
</li>
<li><p>invokevirtual #5 在常量池中找出5号内容，找到新的方法，再分配一个新的栈帧，将栈顶的内容传递给新的栈帧，新方法结束之后，会将栈帧将方法栈中弹出，然后清空操作数栈，return就结束，同时主方法的栈帧在方法栈中也被弹出</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125111252811.png" alt="image-20220125111252811"></p>
</li>
</ul>
<h3 id="a"><a href="#a" class="headerlink" title="a++"></a>a++</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125112517212.png" alt="image-20220125112517212"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125141547292.png" alt="image-20220125141547292"></p>
<ul>
<li>iinc 是在局部变量上直接进行加一</li>
<li>a++ 是先load在iinc</li>
<li>++a 实现iinc在load</li>
<li>iinc  槽位，自增值</li>
</ul>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125142241912.png" alt="image-20220125142241912"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125142335805.png" alt="image-20220125142335805"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125142355639.png" alt="image-20220125142355639"></p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125142922335.png" alt="image-20220125142922335"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125143057342.png" alt="image-20220125143057342"></p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="cinit-V-整个类的构造方法"><a href="#cinit-V-整个类的构造方法" class="headerlink" title="cinit() V            整个类的构造方法"></a>cinit() V            整个类的构造方法</h4><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125144615624.png" alt="image-20220125144615624"></p>
<p>会将所有的静态代码块进行以下整合，整合之后，在类创建时，会从上至下进行执行</p>
<h4 id="init（）V-每个实例对象的构造方法"><a href="#init（）V-每个实例对象的构造方法" class="headerlink" title="init（）V                    每个实例对象的构造方法"></a>init（）V                    每个实例对象的构造方法</h4><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125145433813.png" alt="image-20220125145433813"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125151511169.png" alt="image-20220125151511169"></p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125151846730.png" alt="image-20220125151846730"></p>
<p>字节码如下</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125152637383.png" alt="image-20220125152637383"></p>
<ul>
<li>new 分配内存，分配成功将对象的引用放入操作数栈</li>
<li>dup 复制栈顶的地址，都是刚刚new出的引用</li>
<li>invokespecial  #3     调用栈顶引用的方法 （#3对应常量池的方法），调用结束后，引用会被删除</li>
<li>astore_1 将另一个对象引用存储到局部变量表中</li>
<li>aload_1 在局部变量表中引入</li>
<li>pop是将刚刚调入的引用删除掉，因为后面要执行静态方法，不需要该对象</li>
</ul>
<p>invokestatic和invokespecial都是调用确定的方法，例如像是静态方法，构造方法，私有方法，这一类直接可以找到方法的入口地址。</p>
<p>invokevirtual则是去调用那些不确定的方法，例如public这一类的，这一类可被重写，需要多次访问获取方法的入口地址，因此会动态进行调用，即动态绑定</p>
<h3 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h3><p>来到jdk目录下输入以下命令，启动hsdb工具</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure>

<p>进入图形界面attach 进程id</p>
<p>禁用指针压缩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseCompressedOops -XX:-UsecompressedClassPointers</span><br></pre></td></tr></table></figure>

<p>file下连接到Hotspot process</p>
<p>tools下选择  find object by query</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125163804574.png" alt="image-20220125163804574"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125163727447.png" alt="image-20220125163727447"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125164403679.png" alt="image-20220125164403679"></p>
<p>这里就是class的底层结构</p>
<p>分为对象头和成员变量，该对象只有对象头</p>
<p>前八字节是对象markword，锁标记等</p>
<p>后八字节是类型指针</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220125165450657.png" alt="image-20220125165450657"></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">          i=<span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">          i=<span class="number">20</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127101135580.png" alt="image-20220127101135580"></p>
<p>上图为字节码文件</p>
<p>exception table中就是存储着处理异常的位置</p>
<p>由2到5，监管位置不包括尾，即不对第五行进行异常监督</p>
<p>若出现异常会与监管的异常相匹配则会跳到target指向的位置</p>
<p>八号这里的astore_2就是将异常对象存入到变量表中</p>
<p><strong>关于多个异常处理和判断异常这里写出代码反编译就可以理解</strong></p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           i=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           i=<span class="number">20</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            i=<span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节码文件</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127102606835.png" alt="image-20220127102606835"></p>
<p>astore_3 是将并非我们要补获的异常存储到3号槽中，然后aload3则是将该异常取出来，在由athrow进行抛出</p>
<h5 id="面试题1"><a href="#面试题1" class="headerlink" title="面试题1"></a>面试题1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回2</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127103754894.png" alt="image-20220127103754894"></p>
<p>由字节码可以看出，仅仅将1存储到局部变量表，最终返回的却是2，</p>
<p>出现异常时也类似解读</p>
<p>这也出现了问题，finally中出现了return，就会吞掉异常这就导致了异常不被捕获</p>
<h5 id="面试题2"><a href="#面试题2" class="headerlink" title="面试题2"></a>面试题2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">          i=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>字节码文件</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127104931777.png" alt="image-20220127104931777"></p>
<p>整体的思路就是将要返回的值保存到局部变量表中，等到finally时也还是会返回刚刚要返回的值</p>
<h3 id="symchronized"><a href="#symchronized" class="headerlink" title="symchronized"></a>symchronized</h3><p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节码文件</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127110246682.png" alt="image-20220127110246682"></p>
<p>dup对o进行复制两次引用</p>
<p>第一个引用用于调用构造方法</p>
<p>第二个放入局部常量表中</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127110816075.png" alt="image-20220127110816075"></p>
<h2 id="编译期处理"><a href="#编译期处理" class="headerlink" title="编译期处理"></a>编译期处理</h2><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>java编译器将*.java源码编译为class文件的过程中，自动生成和转换的以写代码，主要为了减轻程序员的负担，成为语法糖</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>尽管我们没有设置构造方法，jvm会自动帮我们生成一个构造方法，在字节码中可以体现</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127112511263.png" alt="image-20220127112511263"></p>
<p>这里的字节码文件里还是给我们生成了构造方法</p>
<h3 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h3><p>即java的<strong>基本类型与包装类型之间会有自动的类型转换</strong>，是在JDK5之后加入的</p>
<p>如下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Integer x=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> y=x;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>装箱</strong>：基本类型到封装类型</p>
<p><strong>拆箱</strong>：封装到基本类型</p>
<h3 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h3><p>泛型也是在JDK 5开始加入的特性，但java在编译泛型代码后会执行泛型擦除的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了Object类型来处理;</p>
<p>如下图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     list.add(<span class="number">10</span>);</span><br><span class="line">    Integer integer = list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节码文件</strong></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220127113256813.png" alt="image-20220127113256813"></p>
<p>由14行命令可以看出，当泛型对象生成结束之后，而后在对泛型对象操作时并不会按照泛型的类型来调用方法，而是直接按照一律object来处理，这就是泛型的擦除</p>
<p>在返回时也是直接返回object，但是返回之后会在27这里进行一下类型的转换，也就是checkcast</p>
<h2 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220210111658333.png" alt="image-20220210111658333"></p>
<p>例如访问String时，先访问String.class（这就是_java_mirror），通过这个class在调用instanceKlass在进行操作</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220210112358422.png" alt="image-20220210112358422"></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li><p>验证：验证类是否符合JVM规范，安全性检查</p>
</li>
<li><p>准备：为static变量分配空间，设置默认值（分配空间与赋值是分开的）</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220210114608344.png" alt="image-20220210114608344"></p>
<p>测试代码如下</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220210115258406.png" alt="image-20220210115258406"></p>
</li>
<li><p>解析</p>
<p>将常量池中的符号引用解析为直接引用</p>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>其实就是<strong>cinit</strong>阶段，虚拟机需保证这个各类的构造方法的线程安全</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220211095631243.png" alt="image-20220211095631243"></p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220211101849309.png" alt="image-20220211101849309"></p>
<p>由上而下，加载器的优先级依次减小，优先级小的加载器加载类时需要先询问优先级高的是否加载过，从而判断是否要加载，例如ac问ec，ec问bc。这种委托方式称为双亲委派的加载模式。</p>
<p>bc无法直接由java调用，因为bc是c++写的。</p>
<h3 id="Bootstrap-Classloader（启动器加载类）"><a href="#Bootstrap-Classloader（启动器加载类）" class="headerlink" title="Bootstrap Classloader（启动器加载类）"></a>Bootstrap Classloader（启动器加载类）</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220211102649011.png" alt="image-20220211102649011"></p>
<p>/a后追加的路径就是将该路径追加至jre/lib下，从而调用bc</p>
<h3 id="Extention-classloader（扩展器加载类）"><a href="#Extention-classloader（扩展器加载类）" class="headerlink" title="Extention classloader（扩展器加载类）"></a>Extention classloader（扩展器加载类）</h3><p><strong>打jar包</strong></p>
<p>因为需要打成jar包放在ec地文件目录下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf my.jar com/xiaow/**.class</span><br></pre></td></tr></table></figure>

<p>放在ec的目录下，这样在new时，会一级一级向上查询，优先级高的进行加载</p>
<p>就不会使用ac加载</p>
<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>委派上级优先做类的加载，若上级没有再由本级进行加载</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220211112432509.png" alt="image-20220211112432509"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220211112539658.png" alt="image-20220211112539658"></p>
<p>大致的过程就是先是一步步向上级调用，来查找目标class，一旦parent为null，代表上级已是bc，此时直接调用特定方法，由bc进行加载，若加载为空，则由本层加载，然后返回加载的值，下级收到之后在进行判断是否进行查找或直接返回</p>
<p>每级被调用时都需要在本级中查找一下是否已经加载了</p>
<h3 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h3><p>这里仔细看看</p>
<p>目前理解：并未采取双亲加载机制进行加载，而是采用直接调用ac进行加载</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220211185711483.png" alt="image-20220211185711483"></p>
<ul>
<li>不同的类加载器加载的类并不是同一个</li>
<li>加载器相同，包名和类名相同才被认为是一个class</li>
</ul>
<h4 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h4><p>这里主要是要重写findclass方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String path = <span class="string">&quot;D:\\java\\&quot;</span> + name + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            ByteArrayOutputStream out=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            Files.copy(Paths.get(path),out);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = out.toByteArray();</span><br><span class="line">            Class&lt;?&gt; aClass = defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> aClass;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>加载自定义位置的类</strong></p>
<p>这里采用了暴力反射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; xiaoW = myClassLoader.loadClass(<span class="string">&quot;xiaow&quot;</span>);</span><br><span class="line">            Field[] declaredFields = xiaoW.getDeclaredFields();</span><br><span class="line">            Field a = xiaoW.getDeclaredField(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            a.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object o = xiaoW.newInstance();</span><br><span class="line">            a.setInt(o,<span class="number">2</span>);</span><br><span class="line">            System.out.println(a.getInt(o));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h2><p>若多次进行相同的操作，运行的时间会慢慢减少</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220212122519292.png" alt="image-20220212122519292"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220212122621352.png" alt="image-20220212122621352"></p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220212122734240.png" alt="image-20220212122734240"></p>
<p><strong>热点代码</strong>：就是执行次数较多的代码</p>
<p><strong>逃逸分析</strong>：观察对象是否会被使用，如果外层不调用该对象，称为不逃逸，这时就不创建对象，C2对字节码进行修改</p>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220212172141517.png" alt="image-20220212172141517"></p>
<p>如上，如果热点方法的内容不是太长，会直接把代码取出来，直接执行，这就称为内联</p>
<p><strong>打印内联信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+unlockDiagnosticvoptions -XX:+PrintInlining</span><br></pre></td></tr></table></figure>

<h3 id="字段优化"><a href="#字段优化" class="headerlink" title="字段优化"></a>字段优化</h3><h2 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h2><p>前十六次调用时会调用本地方法（c++编写），速度比较慢，一旦第十七次之后就开始采用由运行期间动态生成的访问器，这时苏幅就快了</p>
<p>例如反射执行对象的方法时，最开始invoke是调用本地方法进行，在调用次数达到一个阈值之后就会开始调用动态生成的访问器</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220212181746804.png" alt="image-20220212181746804"></p>
<p>这里可以看出来，十七次时调用的invoke实际上是已经开始直接调用该方法了，并未通过反射，效率自然就快要赶上直接调用了。</p>
<p><img src="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/image-20220212181859082.png" alt="image-20220212181859082"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-01-21T08:00:40.000Z" title="2022-1-21 16:00:40">2022-01-21</time>发表</span><span class="level-item"><time dateTime="2022-01-22T13:15:28.786Z" title="2022-1-22 21:15:28">2022-01-22</time>更新</span><span class="level-item">39 分钟读完 (大约5777个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2022/01/21/jvm/">jvm</a></h1><div class="content"><!-- toc -->

<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>java二进制字节码运行环境</p>
<ul>
<li><p>一次编写，到处运行的基础    jvm对外提供了一致的运行环境</p>
</li>
<li><p>自动内存管理机制—垃圾回收功能 </p>
</li>
<li><p>数组下标越界检查 有些语言无法进行检查，可能导致越界的数组数据占据了其他程序的空间</p>
</li>
<li><p>多态 </p>
<h2 id="jre与jvm"><a href="#jre与jvm" class="headerlink" title="jre与jvm"></a>jre与jvm</h2></li>
</ul>
<p>jvm+基础类库——–jre</p>
<p>jre+编译工具——–jdk</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220105164423893.png" alt="image-20220105164423893"></p>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p><img src="/hexo_blog/2022/01/21/jvm/image-20220118204306920.png" alt="image-20220118204306920"></p>
<p>java源码—–》二进制字节码——–》解释器翻译为机器语言——–》cpu来执行</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220105165457742.png" alt="image-20220105165457742"></p>
<h3 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h3><p>记录下一条jvm指令的执行地址，</p>
<p>例如指令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 lalalal</span><br><span class="line">2 啦啦啦啦啦</span><br></pre></td></tr></table></figure>

<p>1执行时，会将2放入程序计数器中，待1执行结束之后就在程序计数器中取得2进行执行，这样依次进行执行</p>
<p>一般是使用寄存器来实现的</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>线程私有</strong> 每一个线程都有自己的程序计数器，当分给该线程的时间片结束之后，假如线程还未完成，则需要进行记录下一条指令的地址，等到重新分配时间片时可以继续执行该程序</li>
<li><strong>不会内存溢出</strong></li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>每个线程需要一个栈，存放着多个栈帧，一个栈帧对应一个方法，每个方法运行时需要的内存</p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><ul>
<li>参数</li>
<li>局部变量</li>
<li>返回地址</li>
</ul>
<p>一个栈中可以有多个栈帧</p>
<p>每个线程只能有一个活动栈帧（）</p>
<p>这里方法调用的栈可以在idea中直观看到</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220113164920042.png" alt="image-20220113164920042"></p>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><ul>
<li><p>垃圾回收不涉及到栈内存</p>
</li>
<li><p>栈内存大小可通过 -Xss size 来设置程序栈大小</p>
<ul>
<li><p>windows取决于虚拟内存大小</p>
</li>
<li><p>linux/macos/Oracle默认为1024kb</p>
</li>
<li><p>并不是栈越大越好，栈越大可运行的线程越少</p>
</li>
<li><p>idea通过以下方式进行设置</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220113171844104.png" alt="image-20220113171844104"></p>
</li>
</ul>
</li>
<li><p>局部变量是否线程安全</p>
<ul>
<li>就看变量是线程私有的还是共享的</li>
<li>线程私有就不需要考虑线程是否安全，共享的话就需要考虑</li>
<li>如果方法内的局部变量未逃离方法作用范围，就是线程安全的，例如如果该变量作为返回值，那么其他线程就可能会拿到这个变量，那么就会导致不安全</li>
</ul>
</li>
</ul>
<h4 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h4><ul>
<li><p>栈内存放的栈帧数量超出了栈的大小就回导致占内存溢出===》递归就可以做到，一直递归不停，就会产生栈内存溢出 </p>
</li>
<li><p>栈帧过大也会导致栈内存溢出</p>
</li>
</ul>
<h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p><strong>定位</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">top：定位哪一个进程对cpu占用高</span><br><span class="line"></span><br><span class="line">ps H -eo pid,tid,%cpu | grep 进程id：进一步定位哪一个线程引起的 </span><br><span class="line">jstack 进程id：列出该进程的所有的线程的信息</span><br></pre></td></tr></table></figure>



<p><strong>长时间未输出结果</strong></p>
<p> jstack 进程id 列出所有的线程信息，可以展示出死锁信息</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法不是由java编写的，因为java无法直接与计算机底层进行交互，因此需要通过本地方法来进行对底层的交互，一般本地方法是由c或c++编写的。</p>
<p>这些本地方法利用的就是本地方法栈 </p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>线程共享的，需要考虑线程安全问题</li>
<li>new创建的对象都是存放在堆</li>
<li>有垃圾回收机制</li>
</ul>
<h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p>不断生成新对象，并且所有对象一直在使用，就会导致堆内存溢出</p>
<p>修改堆空间大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx 8m</span><br></pre></td></tr></table></figure>

<p>以下代码可以用来测试堆空间是否溢出的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">     String s=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     List&lt;String&gt; list =<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     count=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">         s=s+s;</span><br><span class="line">         list.add(s);</span><br><span class="line">         count++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">     System.out.println(count);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>启示</strong></p>
<p>服务器内存越跑越小，可能是因为有一些内存未被来得及回收</p>
<h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><ul>
<li><p>jps工具：查看系统中有哪些java进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure></li>
<li><p>jmap工具：查看堆内存占用情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程id</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">byte</span> array[]=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line">          System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">          array=<span class="keyword">null</span>;</span><br><span class="line">          System.gc();</span><br><span class="line">          System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>jconsole工具：有ui的，多功能的检测工具</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jconsole</span><br></pre></td></tr></table></figure>

<ul>
<li>jvisualvm</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>存放方法，构造器，成员属性之类的数据</p>
<p>方法区在虚拟机启动时就创建，逻辑上是堆的组成部分，但不同的厂商不一定按照这个实现</p>
<h4 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h4><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>常量池： </p>
<p>就是一张常量表，虚拟机指令根据这张常量表找到要执行的类名和方法名，参数类型，字面量等信息</p>
<p>运行时常量池：</p>
<p>常量池是*.class中的，当该类被加载，他的常量池信息就会放入运行时常量池中，并且把里面的符号地址变为真实地址</p>
<h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v Main.class</span><br></pre></td></tr></table></figure>

<p>这里编译的class文件在out文件夹下</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220114113857338.png" alt="image-20220114113857338"></p>
<p>如下图就是常量池</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220114114710142.png" alt="image-20220114114710142"></p>
<h4 id="常量池加载过程"><a href="#常量池加载过程" class="headerlink" title="常量池加载过程"></a>常量池加载过程</h4><p><img src="/hexo_blog/2022/01/21/jvm/image-20220118155538144.png" alt="image-20220118155538144"></p>
<p>最开始时常量池中是没有数据的，是在一步步加载中填入的，是一种懒加载机制</p>
<ul>
<li>常量池存放常量的结构是hash表，每次需要常量时就会以常量在hash表中查找，若不存在则创建</li>
</ul>
<h4 id="常量池与串池的区别"><a href="#常量池与串池的区别" class="headerlink" title="常量池与串池的区别"></a>常量池与串池的区别</h4><p>运行常量池（constant pool）中存放的仅仅是符号，而并非对象，串池（StringTable）中存放的则是字符串对象，作用就是防止创建重复的字符对象</p>
<h4 id="1-6和1-8中常量池和串池存放位置的差别"><a href="#1-6和1-8中常量池和串池存放位置的差别" class="headerlink" title="1.6和1.8中常量池和串池存放位置的差别"></a>1.6和1.8中常量池和串池存放位置的差别</h4><p><img src="/hexo_blog/2022/01/21/jvm/image-20220118165905767.png" alt="image-20220118165905767"></p>
<h4 id="StringTable（串池）的垃圾回收"><a href="#StringTable（串池）的垃圾回收" class="headerlink" title="StringTable（串池）的垃圾回收"></a>StringTable（串池）的垃圾回收</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx16m -XX: +PrintStringTablestatistics -XX: +PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>

<p>-Xmx16m ：设置堆的大小</p>
<p>-XX: +PrintStringTablestatistics ：打印串池中的对象信息</p>
<p>-XX: +PrintGCDetails -verbose:gc : 若存在垃圾回收，则进行打印信息</p>
<p>-XX: StringTableSize=200000 : 因为串池的结构是数组加链表这种方式，数组中的一个关键字称为一个桶，这里就是设计桶的数量，桶的数量越大性能越好，但相对的占用空间就可能过大，造成资源浪费</p>
<h4 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h4><ul>
<li>可以适当调大STringTable的数组长度也就是桶的数量，可以减少冲突从而使得查找效率得到提升</li>
<li>使用串池可对系统性能进行调优，若是<strong>new出来的字符串对象只存在堆中，并不会进入串池</strong>中，这时若是存在大量的重复的字符串对象，可以采用串池来对这些数据进行<strong>去重</strong>，所谓去重就是将利用串池的特性将大量的重复的字符串对象只存储一个字符串对象，其他对象只是对其的引用</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p><strong>操作系统内存</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220118204448078.png" alt="image-20220118204448078"></p>
<h4 id="ByteBuffer为什么读写更快"><a href="#ByteBuffer为什么读写更快" class="headerlink" title="ByteBuffer为什么读写更快"></a>ByteBuffer为什么读写更快</h4><p>使用ByteBuffer实际上就是通过直接内存进行读取</p>
<p><strong>传统io操作</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220119123425858.png" alt="image-20220119123425858"></p>
<p>因为java无法直接访问系统资源，因此需要再建立一个java缓冲区，整个过程就是：本地文件==》系统缓存==》java缓存==》使用</p>
<p><strong>直接内存的io方式</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220119123622038.png" alt="image-20220119123622038"></p>
<p>此时文件直接放入直接内存缓冲区中，java可以直接读取，减少了一层缓冲区，从而使得速度得到提升</p>
<h4 id="直接内存的溢出"><a href="#直接内存的溢出" class="headerlink" title="直接内存的溢出"></a>直接内存的溢出</h4><p>因为DM不受java垃圾机制管理，因此可能会出现内存溢出问题</p>
<p><strong>测试代码</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220119124146715.png" alt="image-20220119124146715"></p>
<h4 id="直接内存分配与释放的原理"><a href="#直接内存分配与释放的原理" class="headerlink" title="直接内存分配与释放的原理"></a>直接内存分配与释放的原理</h4><p>通过代码来申请直接内存的大小，这里直接内存不受jvm管理，因此需要在任务管理器里查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer=ByteBuffer.allocateDirect(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>直接内存的回收是通过unsafe对象来进行回收的</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220119152850973.png" alt="image-20220119152850973"></p>
<h4 id="禁用显示回收的影响"><a href="#禁用显示回收的影响" class="headerlink" title="禁用显示回收的影响"></a>禁用显示回收的影响</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.gc（）     <span class="comment">//显式的垃圾回收</span></span><br></pre></td></tr></table></figure>

<p>关闭显示垃圾回收机制，即System.gc（）无效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC    </span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>即有一个引用该对象，则计数器加一，为0则释放，</p>
<p><strong>弊端</strong></p>
<p>循环引用：即A引用B,B也引用A，没有其他引用他们，但是他们互相引用，都无法释放，就会导致内存泄漏</p>
<h4 id="可达性分析算法（java中使用的垃圾回收机制）"><a href="#可达性分析算法（java中使用的垃圾回收机制）" class="headerlink" title="可达性分析算法（java中使用的垃圾回收机制）"></a>可达性分析算法（java中使用的垃圾回收机制）</h4><p><strong>根对象</strong>：肯定不可以当作垃圾回收的对象</p>
<p>如果一个对象没有被根对象引用，就可以回收</p>
<p><strong>解析</strong></p>
<p>扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</p>
<p><strong>抓取当前堆使用的快照</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump :format=b,live,file=<span class="number">1.</span>bin <span class="number">21384</span></span><br></pre></td></tr></table></figure>

<p>-dump ==》存储</p>
<p>format=b ==》存储二进制文件</p>
<p>live ==》只记录那些未被垃圾回收的内容</p>
<p>file=1.bin 设置存储文件</p>
<p>21384 进程id（jps获取活动的java的进程id）</p>
<p><strong>mat查看gc root对象</strong></p>
<p>System class 系统对象</p>
<p>Busy Monitor 加锁的对象</p>
<p>Thread 活动线程中的对象，局部对象所引用的对象可左gcroot，同时参数中对象也是可以作为gcroot对象</p>
<p><strong>可以作为GC Root的对象</strong></p>
<p>System class 系统对象</p>
<p>Busy Monitor 加锁的对象</p>
<p>Thread 活动线程中的对象，局部对象所引用的对象可左gcroot，同时参数中对象也是可以作为gcroot对象</p>
<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><p><img src="/hexo_blog/2022/01/21/jvm/image-20220119162157683.png" alt="image-20220119162157683"></p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>例如new出来的就是强引用</p>
<p><strong>特点</strong></p>
<ul>
<li>只要沿着gc root链可以找到该对象，就无法被垃圾回收，例B对A-A4，以及ByteBuffer</li>
<li>只要没有直接或则间接对其强引用之后就可以垃圾回收了</li>
</ul>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p><strong>特点</strong></p>
<ul>
<li>只要未被gc root直接引用，垃圾回收时就会自动回收，例从C到软引用再到A2，当然此时需要B不在引用A2时，就可以发生垃圾回收</li>
</ul>
<p><strong>应用场景</strong></p>
<p>强引用下导致堆空间溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 强引用会导致堆空间不够用</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">int</span> _1M=<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">     List&lt;<span class="keyword">byte</span>[]&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M*<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>软引用下</p>
<p>在这种方式下其实就是使用软引用进行嵌套强引用，也就是SoftReference嵌套byte数组，从而达到软引用的目的，这样一旦出现堆内存不够就会进行释放软引用对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">    SoftReference softReference=<span class="keyword">new</span> SoftReference(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M*<span class="number">2</span>]);</span><br><span class="line">    list.add(softReference);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个过程中一旦出现了堆空间不够，就会清理软引用对象引用的对象，但是此时软引用对象还在，虽然占据内存比较小，但最好还是清理一下</p>
<p>使用引用队列进行处理，下方代码，关联了软引用队列，软引用关联的对象回收时，软引用对象会加入队列中，从而实现回收</p>
<p>这里我个人的理解就是判断这些软引用有没有引用其他对象，如果没有，则将其在队列中删除，从而将队列对软引用对象的强引用解除掉，从而实现对象的回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 关联了软引用队列，软引用关联的对象回收时，软引用对象会加入队列中，从而实现回收</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; referenceQueue=<span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">     List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">         SoftReference softReference=<span class="keyword">new</span> SoftReference(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M*<span class="number">2</span>],referenceQueue);</span><br><span class="line">         list.add(softReference);</span><br><span class="line">     &#125;</span><br><span class="line">     Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = referenceQueue.poll();</span><br><span class="line">     <span class="keyword">while</span>(poll!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         referenceQueue.remove();</span><br><span class="line">         poll=referenceQueue.poll();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p><strong>特点</strong></p>
<ul>
<li>当没有强引用时，若内存不够会回收软引用的对象，无论够不够都会回收弱引用对象</li>
<li>释放之后，因为软弱引用仍占用空间，因此需将二者放入引用队列中，进行循环依次释放空间</li>
</ul>
<p><strong>应用实例</strong></p>
<h4 id="虚引用（必须配合引用队列）"><a href="#虚引用（必须配合引用队列）" class="headerlink" title="虚引用（必须配合引用队列）"></a>虚引用（必须配合引用队列）</h4><p><img src="/hexo_blog/2022/01/21/jvm/image-20220121110409118.png" alt="image-20220121110409118"></p>
<p>之前的bytebuffer就是需要一个虚引用对象Cleaner，因为ByteBuffer若是在强引用引用结束之后，会对其进行回收，但是此时直接内存不由jvm管理，这就需要把虚引用对象放置在引用队列中，从而实现对直接内存的回收（虚引用对象就是Cleaner，来调用Unsafe的Free memory（）来进行释放）</p>
<h4 id="终结器引用（必须配合引用队列）"><a href="#终结器引用（必须配合引用队列）" class="headerlink" title="终结器引用（必须配合引用队列）"></a>终结器引用（必须配合引用队列）</h4><p>例如A对象重写了finalize，并且A即将被垃圾回收，会调用finalize方法，将放置一个终结器引用到队列中，会有一个优先级很低的线程会来检查队列中有无需要释放的引用，从而实现对象的回收</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><ul>
<li>判断哪些对象未被gcroot对象引用，对其进行标记</li>
<li>对标记对象进行清除，将对象的首地址存储在队列中，在新的对象分配地址时，会在队列中进行查找，判断有无空间，在进行分配</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>清除速度快</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>会产生大量的碎片空间，导致总剩余空间虽然足够，但有些大空间对象仍无法分配到足够的内存，导致内存溢出</li>
</ul>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><ul>
<li>判断哪些对象未被gcroot对象直接或间接引用，对其进行标记</li>
<li>清楚时，将可用的对象向前移动，从而使得内存空间更见紧凑，从而实现空间更加连续</li>
</ul>
<p><strong>优点</strong></p>
<p>没有内存碎片</p>
<p><strong>缺点</strong></p>
<p>耗费时间较多，例如如果有引用对象引用就是将移动的对象，需要修改大量内容，造成浪费时间</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="/hexo_blog/2022/01/21/jvm/image-20220121121912340.png" alt="image-20220121121912340"></p>
<p>划分成两片区域，将from中存活的对对象复制到to中，待复制结束之后就对from所有的对象进行回收，然后交换from与to的位置</p>
<p><strong>优点</strong></p>
<ul>
<li>没有碎片空间</li>
</ul>
<p><strong>缺点</strong></p>
<p>需要占用双倍的内存空间</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>三种算法都会协同工作</p>
<h3 id="大对象直接到老年代"><a href="#大对象直接到老年代" class="headerlink" title="大对象直接到老年代"></a>大对象直接到老年代</h3><p>超过新生代大小时，直接到老年代中存放</p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p><img src="/hexo_blog/2022/01/21/jvm/image-20220121122327319.png" alt="image-20220121122327319"></p>
<ul>
<li>长时间使用的放在老年代中，用完即弃的放在新生代中，也可以认为重要的，常用的在老年代中，而不常使用的在新生代中</li>
<li>清理时先清理新生代，如果内存实在不够，再开始清理老年代</li>
</ul>
<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><ul>
<li>最开始对象存放在伊甸园中</li>
<li>一旦伊甸园中内存占满之后，就会开始触发垃圾回收<strong>（Minor GC，新生代回收）</strong></li>
<li>先进行标记，然后将存活的对象复制到幸存区，将复制的对象<strong>寿命+1</strong>.然后交换from与to的位置，伊甸园剩余的对象就可以销毁了</li>
<li>然后又可以向伊甸园中分配对象，直到伊甸园又满了，继续执行上述操作，并且也需要测试from中有没有可以回收的，最后在进行回收伊甸园中与幸存区的对象</li>
<li><strong>幸存区中的寿命超过一个阈值（最大寿命15次，存放寿命的数据是4bit，存放在对象里，4位）之后就会晋升到老年代中，若新生代承受不下了，即使没有到达阈值，也会放在老年代中</strong></li>
<li><strong>minor gc会引发 stop the world，在垃圾回收时需暂停其他用户的线程，直到垃圾回收之后在恢复其他线程的运行</strong></li>
</ul>
<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><ul>
<li>当老年代中内存不足，会先触发minor gc，如果之后空间仍不足，则会触发老年代回收<strong>（Full GC）</strong>，这次回收会将老年代中和新生代中的对象进行回收，也会引起stop the world，并且持续时间更长</li>
<li>老年代中存活的对象很多，并且采用的算法可能是标记清除或标记清理，时间会长。</li>
<li>若full gc 之后仍无从充足空间，则full of mememory error</li>
</ul>
<h3 id="GC参数"><a href="#GC参数" class="headerlink" title="GC参数"></a>GC参数</h3><table>
<thead>
<tr>
<th>含义</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>堆初始大小</td>
<td>-Xms</td>
</tr>
<tr>
<td>堆最大大小</td>
<td>-Xmx或-XX:MaxHeapSize =size</td>
</tr>
<tr>
<td>新生代大小</td>
<td>-Xmn或(-XX:NewSize-size + -XX:MaxNewSize-size )</td>
</tr>
<tr>
<td>幸存区比例(动态)</td>
<td>-XX:InitialSurvivorRatio-ratio和-XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td>幸存区比例（ratio是指伊甸园所在比例）</td>
<td>-XX:SurvivorRatio= ratio</td>
</tr>
<tr>
<td>晋升阈值</td>
<td>-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td>晋升详情</td>
<td>-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td>GC详情</td>
<td>-XX:+PrintGCDetails -verbose:ge</td>
</tr>
<tr>
<td>FullGC前MinorGC</td>
<td>-XX:+ScavengeBeforeFullGC</td>
</tr>
<tr>
<td>幸存区比例不会变化的垃圾回收器</td>
<td>-XX: +UseSerialGC</td>
</tr>
<tr>
<td>串行垃圾回收器（新生代是复制算法，老年是标记整理算法）</td>
<td>-XX:+UseSerialGC= Serial + Serialold</td>
</tr>
</tbody></table>
<h3 id="解析垃圾回收信息"><a href="#解析垃圾回收信息" class="headerlink" title="解析垃圾回收信息"></a>解析垃圾回收信息</h3><p><strong>设置的虚拟机参数：</strong></p>
<p>-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:ge</p>
<p><strong>控制台信息</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220121201703726.png" alt="image-20220121201703726"></p>
<ul>
<li>new generation : 新生代  这里总容量9m的原因是因为默认认为to不可以被占用，因此就默认减去了1m<ul>
<li>eden ： 伊甸园</li>
<li>from ：幸存区的from区</li>
<li>to ： 幸存区的 to 区</li>
</ul>
</li>
<li>tenured generatioin ： 老年代</li>
<li>meta space : 元空间</li>
<li>后面的数字就是内存地址</li>
<li>默认的伊甸园占的比例是0.8</li>
</ul>
<h4 id="内存溢出在子线程会不会引起主线程结束"><a href="#内存溢出在子线程会不会引起主线程结束" class="headerlink" title="内存溢出在子线程会不会引起主线程结束"></a>内存溢出在子线程会不会引起主线程结束</h4><p>子线程的内存溢出并不会引起主线程结束</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><ul>
<li><strong>单线程</strong></li>
<li>适用于堆内存小，适合个人电脑</li>
</ul>
<p><strong>虚拟机参数</strong></p>
<p>-XX:+UseSerialGC= Serial + Serialold</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220122113807682.png" alt="image-20220122113807682"></p>
<p>所有的线程须达到安全点之后才可以执行垃圾回收</p>
<p>其他线程需要等到垃圾回收线程结束之后才可以开始继续运行</p>
<h3 id="吞吐量优先（垃圾回收时间占用总时间越少，吞吐量越高）"><a href="#吞吐量优先（垃圾回收时间占用总时间越少，吞吐量越高）" class="headerlink" title="吞吐量优先（垃圾回收时间占用总时间越少，吞吐量越高）"></a>吞吐量优先（垃圾回收时间占用总时间越少，吞吐量越高）</h3><ul>
<li>优先</li>
<li>适用于堆内存较大，多核cpu</li>
<li><strong>单位时间</strong>内stw时间最短（总体时间）</li>
</ul>
<p><strong>虚拟机配置（1.8默认的）</strong></p>
<p>并行的</p>
<p><strong>新生代的（复制算法）</strong>          <strong>老年代的（标记整理算法）</strong></p>
<p>-XX:+UseParallelGC              -XX: +UseParallelOldGC</p>
<p>开启上述其中一个，另一个会自动开启</p>
<p><strong>设置垃圾回收线程个数</strong></p>
<p>-XX: ParallelGCThreads=n</p>
<p><strong>自适应调整新生代的大小，晋升阈值也会受影响</strong></p>
<p>-XX;+UseAdaptivesizePolicy</p>
<p><strong>调整吞吐量的目标，调整垃圾回收与总时间的占比</strong></p>
<p>-XX:GCTimeRatio=ratio（垃圾回收时间比例=1/（1+ratio））</p>
<p><strong>最大暂停毫秒数，最大是200ms</strong></p>
<p>-XX:MaxGCPauseMillis=ms</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220122155817392.png" alt="image-20220122155817392"></p>
<p>也是所有线程到达安全点之后，就会开始多线程开始回收，线程个数与cpu核数有关，核数有多少，线程的上限就是多少</p>
<h3 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h3><ul>
<li>多线程</li>
<li>适用于堆内存较大，多核cpu</li>
<li>注重垃圾回收<strong>单次</strong>stop the world（stw）时间尽可能短</li>
</ul>
<p><strong>并发进行执行垃圾回收</strong></p>
<p>垃圾回收与普通线程同时进行，两类线程互相争夺时间片</p>
<p><strong>老年代</strong>  （标记清除）                                           <strong>新生代</strong></p>
<p>-XX:+UseConcMarkSweepGC   -XX:+UseParNewGC - SerialOld</p>
<p>一旦出现并发问题，老年代GC会退化为串行GC</p>
<p><strong>设置并行线程数</strong>                        <strong>设置并发线程数，建议设置为并行线程数的四分之一</strong></p>
<p>-XX :ParallelGCThreads=n     -XX:ConcGCThreads=threads</p>
<p><strong>只要老年代到达percent之后，就进行清理，是给浮动垃圾留空间</strong></p>
<p>-XX:CMSInitiating0ccupancyFraction=percent</p>
<p><strong>做重新标记之前，先把新生代做一次垃圾回收</strong></p>
<p>这里的原因是因为有新生代要回收的有很多，而且可能新生代还引用了老年代，但这些新生代本身就已经要被清除了，所以即使我们通过他们发现了一些老年代不能进行回收，但是后期这些新生代本身就要进行回收，实际上了做了无用功，因此可以提前对其进行清理，从而达到减少时间的目的</p>
<p>-XX:+CMSScavengeBeforeRemark</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220122162126627.png" alt="image-20220122162126627"></p>
<ul>
<li>初始标记只会标记根对象，此时很快，但是会引发stw</li>
<li>并发标记会标记间接或直接引用的对象，此时与用户线程并发运行</li>
<li>并发标记后会及逆行重新标记，会引起stw（因为并发标记时，标记的内容可能地址会进行改变，因此需重新标记）</li>
<li>重新标记之后会进行并发处理</li>
<li>并发清理过程中，其他线程可能又会有新垃圾（浮动垃圾），这些垃圾下次处理，因此需要专门设置浮动垃圾空间</li>
</ul>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p><img src="/hexo_blog/2022/01/21/jvm/image-20220118162509588.png" alt="image-20220118162509588"></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220118165503266.png" alt="image-20220118165503266"></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="string">&quot;123&quot;</span></span><br><span class="line">String b=<span class="string">&quot;55&quot;</span></span><br><span class="line">String c=a+b</span><br></pre></td></tr></table></figure>

<p>c的赋值其实是先调用Stringbuilder的toString方法生成一个新的String对象，然后返回给c</p>
<p>但是如下图这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="string">&quot;a&quot;</span></span><br><span class="line">String b=<span class="string">&quot;b&quot;</span></span><br><span class="line">String c=<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>;</span><br><span class="line">String d=<span class="string">&quot;ab&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时，c==d是true，因为在编译时，javac会默认认为”a”+”b”就是”ab”，因此直接调用常量池的内容就可以</p>
<h3 id="主动将字符串对象放入串池"><a href="#主动将字符串对象放入串池" class="headerlink" title="主动将字符串对象放入串池"></a>主动将字符串对象放入串池</h3><p>itern（）：将字符串对象放入串池，若不存在，则放入，否则不进行放入</p>
<h2 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p><img src="/hexo_blog/2022/01/21/jvm/image-20220121113317503.png" alt="image-20220121113317503"></p>
<p>原来的占用内存-&gt;回收后的内存，Full GC表示垃圾回收资源太少，因此采用更加强烈的垃圾回收，即软链接垃圾回收</p>
<p>初次回收时会将所有的弱引用对象引用的对象回收掉，若是回收之后内存依然不够，会对软引用在进行回收</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发：并发是指两个或多个事件在同一时间间隔发生</p>
<p>并行：并行是指两个或者多个事件在同一时刻发生。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-22T15:55:27.000Z" title="2021-10-22 23:55:27">2021-10-22</time>发表</span><span class="level-item"><time dateTime="2021-10-22T15:55:52.510Z" title="2021-10-22 23:55:52">2021-10-22</time>更新</span><span class="level-item">5 分钟读完 (大约711个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2021/10/22/%E7%8E%A9%E7%88%AC%E8%99%AB%E4%B8%8D%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93you-get%EF%BC%8C%E5%BF%AB%E8%BF%9B%E6%9D%A5%E7%9C%8B%E7%9C%8B/">玩爬虫不能不知道you-get，快进来看看</a></h1><div class="content"><p>@<a href="you-get%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">TOC</a></p>
<h1 id="什么是you-get"><a href="#什么是you-get" class="headerlink" title="什么是you-get"></a>什么是you-get</h1><p>首先咱们先从字面上分析一下，各位兄弟搬好小板凳，接下来小王利用三年级英语水平给大家翻译一下</p>
<p>首先you的意思是你，get有拿的意思，众所周知英语擅长倒装，没错连起来就是–拿来吧你<br><img src="https://img-blog.csdnimg.cn/1995c20033e0416bbf2decb4db61937f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCx5b6I5pyJ6Laj,size_10,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>引入结束，现在回归正题，其实you-get就是一个别人替我们写好的一个下载神器，可以特别方便的在网络上下载资源，具体怎么使用，咱么继续往下看。</p>
<h1 id="you-get的安装"><a href="#you-get的安装" class="headerlink" title="you-get的安装"></a>you-get的安装</h1><p>前提条件，电脑需要安装python环境，看过博主之前的爬虫文章的兄弟们相信都具备了这个条件，那么接下来就是安装you-get<br>随便打开一个cmd，输入以下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade you-get</span><br></pre></td></tr></table></figure>
<p>安装没有报错，显示内容与与下图显示大致相同，即成功<br><img src="https://img-blog.csdnimg.cn/dc8ceff6f11c48c3b6ace2c8fdce14f9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCx5b6I5pyJ6Laj,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="you-get的使用"><a href="#you-get的使用" class="headerlink" title="you-get的使用"></a>you-get的使用</h1><p>复制资源，然后在你想要存储文件的目录下打开cmd，也就是在地址栏输入cmd即可，如下图<br><img src="https://img-blog.csdnimg.cn/e8b7b01f34bd446aba52da91d71ea4f1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCx5b6I5pyJ6Laj,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在cmd中输入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get 视频链接</span><br></pre></td></tr></table></figure>
<p>如下图所示即下载成功<br><img src="https://img-blog.csdnimg.cn/97f308195606426da69cb99c7ed5c07b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCx5b6I5pyJ6Laj,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>打开下载的文件就可以使用了</p>
<p>更多高级操作大家可以在cmd中输入以下内容进行查看</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get -h</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个小工具的使用，很简单，之前文章中很多人评论，我就专门看了看，最近有时间就写成了博客，下次有缘再写</p>
<p><strong>推荐下自己的爬虫专栏，有几篇基础的爬虫文章，有兴趣的兄弟们可以看看<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/category_11148878.html">基础爬虫专栏</a></strong><br><img src="https://img-blog.csdnimg.cn/6612f96639a546b28b5617230b9b3c10.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCx5b6I5pyJ6Laj,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-24T00:32:53.000Z" title="2021-8-24 8:32:53">2021-08-24</time>发表</span><span class="level-item"><time dateTime="2021-08-24T00:33:22.419Z" title="2021-8-24 8:33:22">2021-08-24</time>更新</span><span class="level-item">8 分钟读完 (大约1246个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2021/08/24/python%E7%88%AC%E5%8F%96%E5%8D%81%E4%B8%87%E5%BC%A0%E8%A1%A8%E6%83%85%E5%8C%85/">python爬取十万张表情包</a></h1><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>事情要从几天前说起，我有一个朋友，他在和他喜欢的小姐姐聊天时，聊天的气氛一直非常尬，这时他就想发点表情包来缓和一下气氛，但一看自己的表情包收藏都是这样的。。。<br><img src="https://img-blog.csdnimg.cn/bab5094aa71d4a7a85db04ea89edfe09.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>。。。这发过去，基本就直接和小姐姐说拜拜了，然后他就向我求救问我有没有表情包，表情包我是没有，但网站有呀，来来，爬虫整起。<br><img src="https://img-blog.csdnimg.cn/a4ce1fc32fc245f794a164d938d2ff70.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="分析页面"><a href="#分析页面" class="headerlink" title="分析页面"></a>分析页面</h1><p>今天爬取的网站是<a target="_blank" rel="noopener" href="https://www.doutula.com/photo/list/">斗图吧</a>，有一说一表情包是真的多，看这惊人的页数<img src="https://img-blog.csdnimg.cn/7b0a25676b03449fab0d41dd7aabb908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70"><br>接下来就该看看怎么拿到表情包图片的url了，首先打开谷歌浏览器，然后点F12进入爬虫快乐模式<br><img src="https://img-blog.csdnimg.cn/f9526a6403084452945e2245f0b334cc.png" alt="在这里插入图片描述"><br>然后完成下图的操作，先点击1号箭头，然后再选中一个表情包即可，红色框中就是我们要爬取的对象，其中表情包的src就在里面<br><img src="https://img-blog.csdnimg.cn/c4db6eba149f4be189ca9fda21557a41.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在我们就搞清楚了怎么拿到表情包的url了，就开始写代码了</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="解析页面"><a href="#解析页面" class="headerlink" title="解析页面"></a>解析页面</h2><h3 id="获取网页内容"><a href="#获取网页内容" class="headerlink" title="获取网页内容"></a>获取网页内容</h3><p>这里就是获取爬取网页的信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">askURL</span>(<span class="params">url</span>):</span></span><br><span class="line">    head = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.106 Safari/537.36&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    req = urllib.request.Request(url=url, headers=head)</span><br><span class="line">    html = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = urllib.request.urlopen(req)</span><br><span class="line">        html = response.read()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="keyword">return</span> html</span><br></pre></td></tr></table></figure>
<h3 id="解析网页内容"><a href="#解析网页内容" class="headerlink" title="解析网页内容"></a>解析网页内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取出图片src的正则式</span></span><br><span class="line">imglink = re.<span class="built_in">compile</span>(</span><br><span class="line">    <span class="string">r&#x27;&lt;img alt=&quot;(.*?)&quot; class=&quot;img-responsive lazy image_dta&quot; data-backup=&quot;.*?&quot; data-original=&quot;(.*?)&quot; referrerpolicy=&quot;no-referrer&quot; src=&quot;.*?&quot;/&gt;&#x27;</span>,</span><br><span class="line">    re.S)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getimgsrcs</span>(<span class="params">url</span>):</span></span><br><span class="line">    html = askURL(url)</span><br><span class="line">    bs = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    names = []</span><br><span class="line">    srcs = []</span><br><span class="line">    <span class="comment"># 找到所有的img标签</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> bs.find_all(<span class="string">&#x27;img&#x27;</span>):</span><br><span class="line">        item = <span class="built_in">str</span>(item)</span><br><span class="line">        <span class="comment"># 根据上面的正则表达式规则把图片的src以及图片名拿下来</span></span><br><span class="line">        imgsrc = re.findall(imglink, item)</span><br><span class="line">        <span class="comment"># 这里是因为拿取的img标签可能不是我们想要的，所以匹配正则规则之后可能返回空值，因此判断一下</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(imgsrc) != <span class="number">0</span>):</span><br><span class="line">            imgname = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> imgsrc[<span class="number">0</span>][<span class="number">0</span>] != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                imgname = imgsrc[<span class="number">0</span>][<span class="number">0</span>] + <span class="string">&#x27;.&#x27;</span> + getFileType(imgsrc[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                imgname = getFileName(imgsrc[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">            names.append(imgname)</span><br><span class="line">            srcs.append(imgsrc[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> names, srcs</span><br></pre></td></tr></table></figure>
<p>到现在为止，已经拿到了所有的图片的链接和名字，那么就可以开始下载了</p>
<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><h3 id="多线程下载"><a href="#多线程下载" class="headerlink" title="多线程下载"></a>多线程下载</h3><p>因为文件实在有点多，所以最好采用多线程的方式下载，我这里只是给了一个样例，大家按照这个逻辑写一下就好</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool = ThreadPoolExecutor(max_workers=<span class="number">50</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(names)):</span><br><span class="line">           pool.submit(FileDownload.downloadFile, urls[j], filelocation[j])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><p><img src="https://img-blog.csdnimg.cn/8929ca48245746dc80c5f806d9b299e9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/d7339c08d7884a5ca79fb5f9b1b98f69.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总共是爬了十万多张表情包，这次咱也是表情包大户了<br><img src="https://img-blog.csdnimg.cn/fe0f759c1b7b4d06852469408416c3f8.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>很简单的一个爬虫，适合我这样的初学者练练手，如果对爬虫有兴趣的话可以看看我的爬虫专栏的其他文章，说不定也有你喜欢的</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/category_11148878.html">爬虫专栏，快来点我呀</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/article/details/119799493">两行代码爬取微博热搜，并实现邮件提醒功能，妈妈再也不用担心我吃不到瓜了 爬虫基础</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/article/details/118662227">python爬取4k小姐姐图片 人生苦短 我用python
</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/article/details/118517916">python爬b站视频 人生苦短 我用python</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/article/details/118077285">Python爬取美女图片 爬虫基础</a></p>
<p>有缘再写，侵权立删</p>
<p><img src="https://img-blog.csdnimg.cn/64ad1d642f274dcd80775b52498a39c3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-20T04:59:01.000Z" title="2021-8-20 12:59:01">2021-08-20</time>发表</span><span class="level-item"><time dateTime="2021-08-20T04:59:35.344Z" title="2021-8-20 12:59:35">2021-08-20</time>更新</span><span class="level-item"><a class="link-muted" href="/hexo_blog/categories/python/">python</a></span><span class="level-item">14 分钟读完 (大约2029个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2021/08/20/ts%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD/">ts视频下载</a></h1><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前一直爬取的内容都是完整的文件，例如一整个mp3或则mp4，但是目前很多视频网站都开始采用ts流媒体视频的方式进行视频的展示，不知道你有没有这样的体验，兴致勃勃的打开一个电影网站，准备开始施展爬虫大法<br><img src="https://img-blog.csdnimg.cn/20210719225220529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查看xhr请求之后，本以为可以找到一个返回mp4的接口，没想到返回的是这一堆ts文件<br><img src="https://img-blog.csdnimg.cn/20210719225300180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>今天我们就来聊一聊怎么下载这些ts文件并将他们拼接为一个mp4</p>
<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><p>ffmpeg，pycharm</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>首先打开谷歌浏览器，F12，查看xhr请求，这一步相信兄弟们已经轻车熟路了。如下图<br><img src="https://img-blog.csdnimg.cn/20210719230452670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>有两个诡异的m3u8，木错，这就是今天我们的突破口，一般第一个m3u8中存储的都是第二个m3u8文件的url，第二个m3u8文件则是存储的ts文件的urll。因为我们这次主要是讲怎么下载ts文件，所以直接用解析第二个m3u8文件，即可。<br>双击这个请求，就可以查看详情，其中Request URL就是调用的接口或则远程文件，直接调用则会下载该m3u8文件，然后解析一下，拿到ts的url列表就可以进行下载了。<br><img src="https://img-blog.csdnimg.cn/20210719230924707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先看一下这个m3u8文件的内容<br><img src="https://img-blog.csdnimg.cn/20210719231345962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>很明显文件中存储的不是ts文件的完整地址，需要我们根据实际情况进行拼接就可以，查看的方式就是点击ts文件xhr请求进行查看如下图，很明显，红框圈中的就是我们要拼接在文件名之前的。这就拿到了真实的ts文件地址。<br><img src="https://img-blog.csdnimg.cn/20210719231700488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么开整代码吧</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="解析m3u8文件，获取ts下载列表"><a href="#解析m3u8文件，获取ts下载列表" class="headerlink" title="解析m3u8文件，获取ts下载列表"></a>解析m3u8文件，获取ts下载列表</h2><p>要使用到m3u8这个库来解析m3u8文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> m3u8</span><br><span class="line">tss = []</span><br><span class="line">order = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#realurl就是存储ts文件地址的m3u8文件的url ，这样返回的数据是json格式的，方便读取数据</span></span><br><span class="line">data = m3u8.load(realurl).data</span><br><span class="line"></span><br><span class="line"><span class="comment"># appendurl就是要拼接在前面的那个地址 这样存入tss的ts文件地址都是真实地址</span></span><br><span class="line"><span class="comment"># order的作用是在将多个ts文件合成一个mp4时，由这个order提供各ts文件拼接的顺序</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data[<span class="string">&quot;segments&quot;</span>]:</span><br><span class="line">        tss.append(appendurl + <span class="string">&quot;/&quot;</span> + i[<span class="string">&quot;uri&quot;</span>])</span><br><span class="line">        order.append(i[<span class="string">&quot;uri&quot;</span>])</span><br></pre></td></tr></table></figure>


<p>到现在为止，ts文件拼接的顺序以及ts文件的真实地址就全部拿到了</p>
<h2 id="多线程下载ts文件，以及ts文件顺序的存储"><a href="#多线程下载ts文件，以及ts文件顺序的存储" class="headerlink" title="多线程下载ts文件，以及ts文件顺序的存储"></a>多线程下载ts文件，以及ts文件顺序的存储</h2><p>有一说一，这些ts文件不仅多，而且小，如果我们只是一个线程下载文件，未免太浪费时间了，而且效率太低了，这次我们采用多线程的方式进行大量ts文件的下载</p>
<h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">url, name</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#记录创立的线程</span></span><br><span class="line">    task_list = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取ts的真实地址和顺序</span></span><br><span class="line">    tss, order = getTss(url)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这里将ts文件顺序存储在m3u8，至于为啥这么做，因为ts文件数量太多了</span></span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&quot;E://file//order.m3u8&quot;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这里将下载ts文件的本地路径输入到order.m3u8之中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> order:</span><br><span class="line">        file.write(<span class="string">f&quot;file &#x27;E:\\file\\ts\\&quot;</span> + i + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        file.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#线程池的创立 </span></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=<span class="number">50</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(order)):</span><br><span class="line">        <span class="comment"># 启动多个线程下载文件</span></span><br><span class="line">        task_list.append(pool.submit(FileDownload.downloadFile, <span class="string">&#x27;E://file//ts//&#x27;</span> + order[i], tss[i]))</span><br><span class="line">    <span class="comment"># 判断所有下载线程是否全部结束</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(task_list) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> task_list:</span><br><span class="line">            <span class="keyword">if</span> i.done():</span><br><span class="line">                task_list.remove(i)</span><br><span class="line">    <span class="comment"># 进行多个ts文件的合并</span></span><br><span class="line">    VideoUtil.mixTss(name)</span><br><span class="line">    <span class="comment"># 合并结束之后把ts文件都删了，不然太占空间了</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> order:</span><br><span class="line">        turl = <span class="string">f&quot;E:\\file\\ts\\&quot;</span> + u</span><br><span class="line">        os.remove(turl)</span><br></pre></td></tr></table></figure>

<h3 id="ts文件顺序存储到本地文件中"><a href="#ts文件顺序存储到本地文件中" class="headerlink" title="ts文件顺序存储到本地文件中"></a>ts文件顺序存储到本地文件中</h3><p><strong>主要代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里将下载ts文件的本地路径输入到order.m3u8之中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> order:</span><br><span class="line">        file.write(<span class="string">f&quot;file &#x27;E:\\file\\ts\\&quot;</span> + i + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        file.write(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>最终文件中存储的内容<br><img src="https://img-blog.csdnimg.cn/20210719233457729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最好按照这种格式存入，之前在网上找的其他格式都会报错，但这个是ok的</p>
<h3 id="多线程下载ts文件"><a href="#多线程下载ts文件" class="headerlink" title="多线程下载ts文件"></a>多线程下载ts文件</h3><p>yysy，多线程真的强，尤其是下载这些小文件，多线程真的是绝了</p>
<p>本文采用线程池的方式，为什么采用线程池呢，因为线程池可以帮我们保留一段时间空闲线程，可以减少线程创建和销毁所耗费的时间，大大提高多线程的效率，同时可以帮助我们限制线程的数量<br><strong>主要代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#线程池的创立 </span></span><br><span class="line">  pool = ThreadPoolExecutor(max_workers=<span class="number">50</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(order)):</span><br><span class="line">      <span class="comment"># 启动多个线程下载文件</span></span><br><span class="line">      task_list.append(pool.submit(FileDownload.downloadFile, <span class="string">&#x27;E://file//ts//&#x27;</span> + order[i], tss[i]))</span><br><span class="line">  <span class="comment"># 判断所有下载线程是否全部结束</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(task_list) == <span class="number">0</span>:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> task_list:</span><br><span class="line">          <span class="keyword">if</span> i.done():</span><br><span class="line">              task_list.remove(i)</span><br></pre></td></tr></table></figure>

<h2 id="ts文件合成mp4"><a href="#ts文件合成mp4" class="headerlink" title="ts文件合成mp4"></a>ts文件合成mp4</h2><p>主要思路就是利用刚刚生成的那个ts顺序文件（order.m3u8），按照文件中的顺序进行ts文件的拼接。</p>
<p>这里拼接ts文件时还是要使用ffmpeg，没有的兄弟们可以看下这个安装一下<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43627076/article/details/118584645">ffmpeg安装教程</a><br><strong>主要代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mixTss</span>(<span class="params">name</span>):</span></span><br><span class="line">    com = <span class="string">r&#x27;D:\\tool\\ffmpeg\\bin\\ffmpeg.exe -f concat -safe 0 -i E:\\file\\order.m3u8 -c copy E:\\file\\video2\\&#123;&#125;.mp4&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        name)</span><br><span class="line">    os.system(com)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里解释一下<br><strong>D:\tool\ffmpeg\bin\ffmpeg.exe</strong>  ：  本地ffmpeg的位置，设置了环境变量直接ffmpeg即可</p>
<p><strong>E:\file\order.m3u8</strong>：刚刚生成的存储ts文件的顺序的文件路径</p>
<p><strong>E:\file\video2\{}.mp4</strong>：视频最终合成之后存放的位置</p>
<p>至此，ts视频的下载以及合成一个mp4就实现了</p>
<h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><h2 id="ts文件"><a href="#ts文件" class="headerlink" title="ts文件"></a>ts文件</h2><p>这是下载过程中截的图，有一说一，看着这些文件爆炸式增加，还挺爽<br><img src="https://img-blog.csdnimg.cn/20210719234816694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="mp4文件"><a href="#mp4文件" class="headerlink" title="mp4文件"></a>mp4文件</h2><p><img src="https://img-blog.csdnimg.cn/20210719235046784.png" alt="在这里插入图片描述"><br>具体就不给你们康了，你们猜猜是啥<br><img src="https://img-blog.csdnimg.cn/20210719235238912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之没有想象的这么难，做之前以为很复杂，其实还好，最后欢迎各位大佬指点。<br><img src="https://img-blog.csdnimg.cn/20210719235440164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-20T04:57:49.000Z" title="2021-8-20 12:57:49">2021-08-20</time>发表</span><span class="level-item"><time dateTime="2021-08-20T04:58:24.265Z" title="2021-8-20 12:58:24">2021-08-20</time>更新</span><span class="level-item"><a class="link-muted" href="/hexo_blog/categories/%E7%88%AC%E8%99%AB/">爬虫</a></span><span class="level-item">10 分钟读完 (大约1469个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo_blog/2021/08/20/Python%E7%88%AC%E5%8F%96%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87/">Python爬取美女图片</a></h1><div class="content"><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>作为一个考研狗，每天除了日复一日的复习外，偶尔也想给自己寻找一些生活的小乐趣，今天突然想到了自己曾经稍微接触的爬虫，想看看可以爬取些图片放到电脑上，就花了些时间改了改之前的爬虫代码，爬取了一部分照片先量一下战绩吧。照片不多但也算是自己的一次爬虫小经验。<br><img src="https://img-blog.csdnimg.cn/20210620234909406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210620234923201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>爬虫的网页很简单，照片真实路径都在页面中直接可以拿到<br>主要流程就是先进入照片浏览的主页，每个照片的主页都会链接几个照片页面，像下面这样，每个图片都会链接一个网页<br><img src="https://img-blog.csdnimg.cn/20210621000150492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">图片链接的网页如下图所示<br><img src="https://img-blog.csdnimg.cn/20210621000255924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是这个页面显示的图片还是不够高清，这个网站有一个规律，更高清的照片存放的网页就在现在这个页面的路径后跟一个  -1920x1080  的htm中，进入这个htm之后展示的照片才是我们要的，拿到图片的url就直接下载就好，就这样一直循环，所有的照片就都下载下来了。</p>
<h1 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h1><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadFile</span>(<span class="params">name, url</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        headers = &#123;<span class="string">&#x27;Proxy-Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>&#125;</span><br><span class="line">        r = requests.get(url, stream=<span class="literal">True</span>, headers=headers)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=========================&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(r)</span><br><span class="line">        length = <span class="built_in">float</span>(r.headers[<span class="string">&#x27;Content-length&#x27;</span>])</span><br><span class="line">        f = <span class="built_in">open</span>(name, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        count_tmp = <span class="number">0</span></span><br><span class="line">        time1 = time.time()</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">512</span>):</span><br><span class="line">            <span class="keyword">if</span> chunk:</span><br><span class="line">                f.write(chunk)  <span class="comment"># 写入文件</span></span><br><span class="line">                count += <span class="built_in">len</span>(chunk)  <span class="comment"># 累加长度</span></span><br><span class="line">                <span class="comment"># 计算时间 两秒打印一次</span></span><br><span class="line">                <span class="keyword">if</span> time.time() - time1 &gt; <span class="number">2</span>:</span><br><span class="line">                    p = count / length * <span class="number">100</span></span><br><span class="line">                    speed = (count - count_tmp) / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">2</span></span><br><span class="line">                    count_tmp = count</span><br><span class="line">                    <span class="built_in">print</span>(name + <span class="string">&#x27;: &#x27;</span> + formatFloat(p) + <span class="string">&#x27;%&#x27;</span> + <span class="string">&#x27; Speed: &#x27;</span> + formatFloat(speed) + <span class="string">&#x27;M/S&#x27;</span>)</span><br><span class="line">                    time1 = time.time()</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;出现异常&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">formatFloat</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    downloadFile(<span class="string">&#x27;D://file//photo//hd.jpg&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;https://browser9.qhimg.com/bdr/__85/t01753453b660de14e9.jpg&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>文件下载没什么好说的，复制就可以用，这里做了一个异常捕获的处理，因为可能出现连接不上资源，或则目标服务器强制关闭连接的可能，做这个异常处理就是为了判断有没有异常出现，从而进行相应的处理</p>
<h2 id="爬虫代码"><a href="#爬虫代码" class="headerlink" title="爬虫代码"></a>爬虫代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- codeing = utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2021/6/19 23:01</span></span><br><span class="line"><span class="comment"># @Author : xiaow</span></span><br><span class="line"><span class="comment"># @File : PhotoSpider.py</span></span><br><span class="line"><span class="comment"># @Software : PyCharm</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  <span class="comment"># 网页解析</span></span><br><span class="line"><span class="keyword">import</span> xlwt  <span class="comment"># excel操作</span></span><br><span class="line"><span class="keyword">import</span> sqlite3  <span class="comment"># 数据库操作</span></span><br><span class="line"><span class="keyword">from</span> api <span class="keyword">import</span> spider2 <span class="keyword">as</span> spider</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> api <span class="keyword">import</span> FileDownload <span class="keyword">as</span> fd</span><br><span class="line"><span class="keyword">import</span> re  <span class="comment"># 正则表达式</span></span><br><span class="line"></span><br><span class="line">imglink = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;a href=&quot;(.*?)&quot; target=&quot;_blank&quot; title=&quot;.*?&quot;&gt;&lt;img alt=&quot;.*?&quot; src=&quot;.*?&quot;/&gt;&lt;b&gt;.*?&lt;/b&gt;&lt;/a&gt;&#x27;</span>, re.S)</span><br><span class="line">img2link = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;a href=&quot;(.*?)&quot; target=&quot;_blank&quot;&gt;.*?&lt;span&gt;（1680x1050）&lt;/span&gt;&lt;/a&gt;&#x27;</span>, re.S)</span><br><span class="line">img3link = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;img alt=&quot;.*?&quot; src=&quot;(.*?)&quot; title=&quot;.*?&quot;/&gt;&#x27;</span>, re.S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取照片页面路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPhoto</span>(<span class="params">url</span>):</span></span><br><span class="line">    srcs = []</span><br><span class="line">    html = spider.askURL(url);</span><br><span class="line">    bs = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> bs.find_all(<span class="string">&#x27;a&#x27;</span>, target=<span class="string">&quot;_blank&quot;</span>):</span><br><span class="line">        item = <span class="built_in">str</span>(item)</span><br><span class="line">        src = re.findall(imglink, item)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(src) != <span class="number">0</span>):</span><br><span class="line">            srcs.append(<span class="string">&quot;http://www.netbian.com&quot;</span> + src[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> srcs;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 照片主页显示的照片不够清楚，这里根据这个网站存储照片的规律，拼接了一个地址，这个地址的照片比较高清一些</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPhotoUrl</span>(<span class="params">url</span>):</span></span><br><span class="line">    purls = [];</span><br><span class="line">    url3 = <span class="string">&quot;http://www&quot;</span>;</span><br><span class="line">    url2 = url.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(url2)):</span><br><span class="line">        <span class="keyword">if</span> j == <span class="built_in">len</span>(url2) - <span class="number">2</span>:</span><br><span class="line">            url3 = url3 + <span class="string">&quot;.&quot;</span> + url2[j] + <span class="string">&quot;-1920x1080&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            url3 = url3 + <span class="string">&quot;.&quot;</span> + url2[j]</span><br><span class="line">    <span class="keyword">return</span> (url3)</span><br><span class="line"><span class="comment"># 下载照片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadPhoto</span>(<span class="params">url</span>):</span></span><br><span class="line">    html = spider.askURL(url);</span><br><span class="line">    bs = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> bs.find_all(<span class="string">&quot;img&quot;</span>):</span><br><span class="line">        item=<span class="built_in">str</span>(item)</span><br><span class="line">        itemsrc=re.findall(img3link,item)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span>(itemsrc)!=<span class="number">0</span>):</span><br><span class="line">           <span class="keyword">return</span> itemsrc[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src = <span class="string">&quot;http://www.netbian.com/mei/index_&quot;</span>;</span><br><span class="line">    <span class="comment"># 拼接照片主页的路径</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">163</span>):</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        src2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        src2=src+<span class="built_in">str</span>(i)+<span class="string">&quot;.htm&quot;</span></span><br><span class="line">        urls=getPhoto(src2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(urls)):</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            fd.downloadFile(<span class="string">&#x27;D://file//photo//hd&#x27;</span>+<span class="built_in">str</span>(time.time())+<span class="string">&quot;.jpg&quot;</span>,downloadPhoto(getPhotoUrl(urls[j])))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><p>展示几张照片吧<br><img src="https://img-blog.csdnimg.cn/20210620235958613.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210621000008150.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210621000017216.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3MDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>解析网页的封装类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- codeing = utf-8 -*-</span></span><br><span class="line"><span class="comment">#@Time : 2021/3/1 16:16</span></span><br><span class="line"><span class="comment">#@Author : xiaow</span></span><br><span class="line"><span class="comment">#@File : spider2.py</span></span><br><span class="line"><span class="comment">#@Software : PyCharm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re  <span class="comment"># 正则表达式</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib.request, urllib.error  <span class="comment"># 指定url，获取网页数据</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  <span class="comment"># 网页解析</span></span><br><span class="line"><span class="keyword">import</span> xlwt  <span class="comment"># excel操作</span></span><br><span class="line"><span class="keyword">import</span> sqlite3  <span class="comment"># 数据库操作</span></span><br><span class="line"></span><br><span class="line">baseurl = <span class="string">&#x27;https://movie.douban.com/top250?start=&#x27;</span></span><br><span class="line"></span><br><span class="line">imglink = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;a href=&quot;.*?&quot; title=&quot;.*?&quot;&gt;&#x27;</span>, re.S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># titlelink = re.compile(r&#x27;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&#x27;)</span></span><br><span class="line"><span class="comment"># findlink = re.compile(r&#x27;&lt;a href=&quot;(.*?)&quot;&gt;&#x27;)  # 创建正则表达式 表示规则</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.爬取网页</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span>(<span class="params">url</span>):</span></span><br><span class="line">    urllist = []</span><br><span class="line">    valuelist = []</span><br><span class="line">    <span class="comment"># 2.解析数据</span></span><br><span class="line">    img = []</span><br><span class="line">    src = []</span><br><span class="line">    title = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        url = baseurl + <span class="built_in">str</span>(i * <span class="number">25</span>)</span><br><span class="line">        html = askURL(url)</span><br><span class="line">        bs = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(bs)</span><br><span class="line">        <span class="comment"># urllist.append(bs.a.attrs[&quot;href&quot;])</span></span><br><span class="line">        <span class="comment"># valuelist.append(bs.a.string)</span></span><br><span class="line">        <span class="comment"># return urllist, valuelist</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> bs.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&quot;item&quot;</span>):  <span class="comment"># 查找div 并且该div应满足class=item</span></span><br><span class="line">            <span class="comment"># print(item)</span></span><br><span class="line">            item = <span class="built_in">str</span>(item)</span><br><span class="line">            <span class="comment"># titlel = re.findall(titlelink, item)</span></span><br><span class="line">            <span class="comment"># title.append(titlel)</span></span><br><span class="line">            <span class="comment"># srcl = re.findall(findlink, item)  # 正则表达式进行筛选</span></span><br><span class="line">            <span class="comment"># for s in srcl:</span></span><br><span class="line">            <span class="comment">#     src.append(s)</span></span><br><span class="line">            imgl = re.findall(imglink, item)  <span class="comment"># 正则表达式进行筛选</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> imgl:</span><br><span class="line">                img.append(i)</span><br><span class="line">    <span class="keyword">return</span> title, img, src;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到一个url的网页内容1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">askURL</span>(<span class="params">url</span>):</span></span><br><span class="line">    head = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.106 Safari/537.36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Cookie&quot;</span>: <span class="string">&#x27;_ga=GA1.2.1191993538.1623990557; _gid=GA1.2.176559558.1623990557; HstCfa3699098=1623990557028; HstCmu3699098=1623990557028; HstCnv3699098=1; HstCns3699098=1; newurl=0; __dtsu=10401623990557D693AE61F09F524965; pbnfgecookieinforecord=%2C64-32128%2C64-32129%2C; HstCla3699098=1623991353818; HstPn3699098=7; HstPt3699098=7&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    req = urllib.request.Request(url=url, headers=head)</span><br><span class="line">    html = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = urllib.request.urlopen(req)</span><br><span class="line">        html = response.read()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.保存数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">savaData</span>(<span class="params">savepath</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/hexo_blog/page/0/">上一页</a></div><div class="pagination-next"><a href="/hexo_blog/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/hexo_blog/">1</a></li><li><a class="pagination-link" href="/hexo_blog/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/hexo_blog/img/123.jpg" alt="XiaoW"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">XiaoW</p><p class="is-size-6 is-block">keep coding keep go on</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>山东</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/hexo_blog/archives"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/hexo_blog/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/hexo_blog/tags"><p class="title">5</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gitee.com/xiaow123" target="_blank" rel="noopener">关注我</a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://gitee.com/xiaow123" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/qq_43627076" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">csdn</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/hexo_blog/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/categories/%E7%88%AC%E8%99%AB/"><span class="level-start"><span class="level-item">爬虫</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/categories/%E9%9A%8F%E7%AC%94/"><span class="level-start"><span class="level-item">随笔</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-09T08:51:20.000Z">2022-04-09</time></p><p class="title"><a href="/hexo_blog/2022/04/09/FastDFS/">FastDFS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-12T13:37:53.000Z">2022-02-12</time></p><p class="title"><a href="/hexo_blog/2022/02/12/juc/">juc</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-12T12:09:33.000Z">2022-02-12</time></p><p class="title"><a href="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/">jvm续集2</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-07T04:02:58.000Z">2022-02-07</time></p><p class="title"><a href="/hexo_blog/2022/02/07/%E8%A7%86%E9%A2%91%E5%88%92%E5%88%86%E4%B8%BAts%E7%89%87%E6%AE%B5/">视频划分为ts片段</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-22T08:51:20.000Z">2022-01-22</time></p><p class="title"><a href="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/">jvm续集</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/hexo_blog/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/Harmony/"><span class="tag">Harmony</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E7%88%AC%E8%99%AB/"><span class="tag">爬虫</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E9%9A%8F%E7%AC%94/"><span class="tag">随笔</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/hexo_blog/"><img src="/hexo_blog/img/logo.svg" alt="xiaow的博客" height="28"></a><p class="is-size-7"><span>&copy; 2022 xiaow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/hexo_blog/js/column.js"></script><script src="/hexo_blog/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/hexo_blog/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/hexo_blog/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/hexo_blog/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/hexo_blog/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>