<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>jvm - xiaow的博客</title><link rel="manifest" href="/hexo_blog/manifest.json"><meta name="application-name" content="xiaow的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="xiaow的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="JVMjava二进制字节码运行环境  一次编写，到处运行的基础    jvm对外提供了一致的运行环境  自动内存管理机制—垃圾回收功能   数组下标越界检查 有些语言无法进行检查，可能导致越界的数组数据占据了其他程序的空间  多态  jre与jvm  jvm+基础类库——–jre jre+编译工具——–jdk  内存结构 java源码—–》二进制字节码——–》解释器翻译为机器语言——–》cpu"><meta property="og:type" content="blog"><meta property="og:title" content="jvm"><meta property="og:url" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/"><meta property="og:site_name" content="xiaow的博客"><meta property="og:description" content="JVMjava二进制字节码运行环境  一次编写，到处运行的基础    jvm对外提供了一致的运行环境  自动内存管理机制—垃圾回收功能   数组下标越界检查 有些语言无法进行检查，可能导致越界的数组数据占据了其他程序的空间  多态  jre与jvm  jvm+基础类库——–jre jre+编译工具——–jdk  内存结构 java源码—–》二进制字节码——–》解释器翻译为机器语言——–》cpu"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220105164423893.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220118204306920.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220105165457742.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220113164920042.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220113171844104.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220114113857338.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220114114710142.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220118155538144.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220118165905767.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220118204448078.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220119123425858.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220119123622038.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220119124146715.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220119152850973.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220119162157683.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220121110409118.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220121121912340.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220121122327319.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220121201703726.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220122113807682.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220122155817392.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220122162126627.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220118162509588.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220118165503266.png"><meta property="og:image" content="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220121113317503.png"><meta property="article:published_time" content="2022-01-21T08:00:40.000Z"><meta property="article:modified_time" content="2022-01-22T13:15:28.786Z"><meta property="article:author" content="xiaow"><meta property="article:tag" content="java,python"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/hexo_blog/2022/01/21/jvm/image-20220105164423893.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/"},"headline":"jvm","image":["https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220105164423893.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220118204306920.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220105165457742.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220113164920042.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220113171844104.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220114113857338.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220114114710142.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220118155538144.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220118165905767.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220118204448078.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220119123425858.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220119123622038.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220119124146715.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220119152850973.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220119162157683.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220121110409118.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220121121912340.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220121122327319.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220121201703726.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220122113807682.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220122155817392.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220122162126627.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220118162509588.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220118165503266.png","https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/image-20220121113317503.png"],"datePublished":"2022-01-21T08:00:40.000Z","dateModified":"2022-01-22T13:15:28.786Z","author":{"@type":"Person","name":"xiaow"},"publisher":{"@type":"Organization","name":"xiaow的博客","logo":{"@type":"ImageObject","url":"https://xiaow123.gitee.io/img/logo.svg"}},"description":"JVMjava二进制字节码运行环境  一次编写，到处运行的基础    jvm对外提供了一致的运行环境  自动内存管理机制—垃圾回收功能   数组下标越界检查 有些语言无法进行检查，可能导致越界的数组数据占据了其他程序的空间  多态  jre与jvm  jvm+基础类库——–jre jre+编译工具——–jdk  内存结构 java源码—–》二进制字节码——–》解释器翻译为机器语言——–》cpu"}</script><link rel="canonical" href="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/"><link rel="icon" href="/hexo_blog/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/hexo_blog/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/hexo_blog/"><img src="/hexo_blog/img/logo.svg" alt="xiaow的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/hexo_blog/">主页</a><a class="navbar-item" href="/hexo_blog/archives">归档</a><a class="navbar-item" href="/hexo_blog/categories">分类</a><a class="navbar-item" href="/hexo_blog/tags">标签</a><a class="navbar-item" href="https://xiaow123.gitee.io/staicpage/html/mine/">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-01-21T08:00:40.000Z" title="2022-1-21 16:00:40">2022-01-21</time>发表</span><span class="level-item"><time dateTime="2022-01-22T13:15:28.786Z" title="2022-1-22 21:15:28">2022-01-22</time>更新</span><span class="level-item">39 分钟读完 (大约5777个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">jvm</h1><div class="content"><!-- toc -->

<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>java二进制字节码运行环境</p>
<ul>
<li><p>一次编写，到处运行的基础    jvm对外提供了一致的运行环境</p>
</li>
<li><p>自动内存管理机制—垃圾回收功能 </p>
</li>
<li><p>数组下标越界检查 有些语言无法进行检查，可能导致越界的数组数据占据了其他程序的空间</p>
</li>
<li><p>多态 </p>
<h2 id="jre与jvm"><a href="#jre与jvm" class="headerlink" title="jre与jvm"></a>jre与jvm</h2></li>
</ul>
<p>jvm+基础类库——–jre</p>
<p>jre+编译工具——–jdk</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220105164423893.png" alt="image-20220105164423893"></p>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p><img src="/hexo_blog/2022/01/21/jvm/image-20220118204306920.png" alt="image-20220118204306920"></p>
<p>java源码—–》二进制字节码——–》解释器翻译为机器语言——–》cpu来执行</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220105165457742.png" alt="image-20220105165457742"></p>
<h3 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h3><p>记录下一条jvm指令的执行地址，</p>
<p>例如指令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 lalalal</span><br><span class="line">2 啦啦啦啦啦</span><br></pre></td></tr></table></figure>

<p>1执行时，会将2放入程序计数器中，待1执行结束之后就在程序计数器中取得2进行执行，这样依次进行执行</p>
<p>一般是使用寄存器来实现的</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>线程私有</strong> 每一个线程都有自己的程序计数器，当分给该线程的时间片结束之后，假如线程还未完成，则需要进行记录下一条指令的地址，等到重新分配时间片时可以继续执行该程序</li>
<li><strong>不会内存溢出</strong></li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>每个线程需要一个栈，存放着多个栈帧，一个栈帧对应一个方法，每个方法运行时需要的内存</p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><ul>
<li>参数</li>
<li>局部变量</li>
<li>返回地址</li>
</ul>
<p>一个栈中可以有多个栈帧</p>
<p>每个线程只能有一个活动栈帧（）</p>
<p>这里方法调用的栈可以在idea中直观看到</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220113164920042.png" alt="image-20220113164920042"></p>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><ul>
<li><p>垃圾回收不涉及到栈内存</p>
</li>
<li><p>栈内存大小可通过 -Xss size 来设置程序栈大小</p>
<ul>
<li><p>windows取决于虚拟内存大小</p>
</li>
<li><p>linux/macos/Oracle默认为1024kb</p>
</li>
<li><p>并不是栈越大越好，栈越大可运行的线程越少</p>
</li>
<li><p>idea通过以下方式进行设置</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220113171844104.png" alt="image-20220113171844104"></p>
</li>
</ul>
</li>
<li><p>局部变量是否线程安全</p>
<ul>
<li>就看变量是线程私有的还是共享的</li>
<li>线程私有就不需要考虑线程是否安全，共享的话就需要考虑</li>
<li>如果方法内的局部变量未逃离方法作用范围，就是线程安全的，例如如果该变量作为返回值，那么其他线程就可能会拿到这个变量，那么就会导致不安全</li>
</ul>
</li>
</ul>
<h4 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h4><ul>
<li><p>栈内存放的栈帧数量超出了栈的大小就回导致占内存溢出===》递归就可以做到，一直递归不停，就会产生栈内存溢出 </p>
</li>
<li><p>栈帧过大也会导致栈内存溢出</p>
</li>
</ul>
<h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p><strong>定位</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">top：定位哪一个进程对cpu占用高</span><br><span class="line"></span><br><span class="line">ps H -eo pid,tid,%cpu | grep 进程id：进一步定位哪一个线程引起的 </span><br><span class="line">jstack 进程id：列出该进程的所有的线程的信息</span><br></pre></td></tr></table></figure>



<p><strong>长时间未输出结果</strong></p>
<p> jstack 进程id 列出所有的线程信息，可以展示出死锁信息</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法不是由java编写的，因为java无法直接与计算机底层进行交互，因此需要通过本地方法来进行对底层的交互，一般本地方法是由c或c++编写的。</p>
<p>这些本地方法利用的就是本地方法栈 </p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>线程共享的，需要考虑线程安全问题</li>
<li>new创建的对象都是存放在堆</li>
<li>有垃圾回收机制</li>
</ul>
<h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p>不断生成新对象，并且所有对象一直在使用，就会导致堆内存溢出</p>
<p>修改堆空间大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx 8m</span><br></pre></td></tr></table></figure>

<p>以下代码可以用来测试堆空间是否溢出的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">     String s=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     List&lt;String&gt; list =<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     count=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">         s=s+s;</span><br><span class="line">         list.add(s);</span><br><span class="line">         count++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">     System.out.println(count);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>启示</strong></p>
<p>服务器内存越跑越小，可能是因为有一些内存未被来得及回收</p>
<h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><ul>
<li><p>jps工具：查看系统中有哪些java进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure></li>
<li><p>jmap工具：查看堆内存占用情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程id</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">byte</span> array[]=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line">          System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">          array=<span class="keyword">null</span>;</span><br><span class="line">          System.gc();</span><br><span class="line">          System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>jconsole工具：有ui的，多功能的检测工具</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jconsole</span><br></pre></td></tr></table></figure>

<ul>
<li>jvisualvm</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>存放方法，构造器，成员属性之类的数据</p>
<p>方法区在虚拟机启动时就创建，逻辑上是堆的组成部分，但不同的厂商不一定按照这个实现</p>
<h4 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h4><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>常量池： </p>
<p>就是一张常量表，虚拟机指令根据这张常量表找到要执行的类名和方法名，参数类型，字面量等信息</p>
<p>运行时常量池：</p>
<p>常量池是*.class中的，当该类被加载，他的常量池信息就会放入运行时常量池中，并且把里面的符号地址变为真实地址</p>
<h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v Main.class</span><br></pre></td></tr></table></figure>

<p>这里编译的class文件在out文件夹下</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220114113857338.png" alt="image-20220114113857338"></p>
<p>如下图就是常量池</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220114114710142.png" alt="image-20220114114710142"></p>
<h4 id="常量池加载过程"><a href="#常量池加载过程" class="headerlink" title="常量池加载过程"></a>常量池加载过程</h4><p><img src="/hexo_blog/2022/01/21/jvm/image-20220118155538144.png" alt="image-20220118155538144"></p>
<p>最开始时常量池中是没有数据的，是在一步步加载中填入的，是一种懒加载机制</p>
<ul>
<li>常量池存放常量的结构是hash表，每次需要常量时就会以常量在hash表中查找，若不存在则创建</li>
</ul>
<h4 id="常量池与串池的区别"><a href="#常量池与串池的区别" class="headerlink" title="常量池与串池的区别"></a>常量池与串池的区别</h4><p>运行常量池（constant pool）中存放的仅仅是符号，而并非对象，串池（StringTable）中存放的则是字符串对象，作用就是防止创建重复的字符对象</p>
<h4 id="1-6和1-8中常量池和串池存放位置的差别"><a href="#1-6和1-8中常量池和串池存放位置的差别" class="headerlink" title="1.6和1.8中常量池和串池存放位置的差别"></a>1.6和1.8中常量池和串池存放位置的差别</h4><p><img src="/hexo_blog/2022/01/21/jvm/image-20220118165905767.png" alt="image-20220118165905767"></p>
<h4 id="StringTable（串池）的垃圾回收"><a href="#StringTable（串池）的垃圾回收" class="headerlink" title="StringTable（串池）的垃圾回收"></a>StringTable（串池）的垃圾回收</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx16m -XX: +PrintStringTablestatistics -XX: +PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>

<p>-Xmx16m ：设置堆的大小</p>
<p>-XX: +PrintStringTablestatistics ：打印串池中的对象信息</p>
<p>-XX: +PrintGCDetails -verbose:gc : 若存在垃圾回收，则进行打印信息</p>
<p>-XX: StringTableSize=200000 : 因为串池的结构是数组加链表这种方式，数组中的一个关键字称为一个桶，这里就是设计桶的数量，桶的数量越大性能越好，但相对的占用空间就可能过大，造成资源浪费</p>
<h4 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h4><ul>
<li>可以适当调大STringTable的数组长度也就是桶的数量，可以减少冲突从而使得查找效率得到提升</li>
<li>使用串池可对系统性能进行调优，若是<strong>new出来的字符串对象只存在堆中，并不会进入串池</strong>中，这时若是存在大量的重复的字符串对象，可以采用串池来对这些数据进行<strong>去重</strong>，所谓去重就是将利用串池的特性将大量的重复的字符串对象只存储一个字符串对象，其他对象只是对其的引用</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p><strong>操作系统内存</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220118204448078.png" alt="image-20220118204448078"></p>
<h4 id="ByteBuffer为什么读写更快"><a href="#ByteBuffer为什么读写更快" class="headerlink" title="ByteBuffer为什么读写更快"></a>ByteBuffer为什么读写更快</h4><p>使用ByteBuffer实际上就是通过直接内存进行读取</p>
<p><strong>传统io操作</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220119123425858.png" alt="image-20220119123425858"></p>
<p>因为java无法直接访问系统资源，因此需要再建立一个java缓冲区，整个过程就是：本地文件==》系统缓存==》java缓存==》使用</p>
<p><strong>直接内存的io方式</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220119123622038.png" alt="image-20220119123622038"></p>
<p>此时文件直接放入直接内存缓冲区中，java可以直接读取，减少了一层缓冲区，从而使得速度得到提升</p>
<h4 id="直接内存的溢出"><a href="#直接内存的溢出" class="headerlink" title="直接内存的溢出"></a>直接内存的溢出</h4><p>因为DM不受java垃圾机制管理，因此可能会出现内存溢出问题</p>
<p><strong>测试代码</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220119124146715.png" alt="image-20220119124146715"></p>
<h4 id="直接内存分配与释放的原理"><a href="#直接内存分配与释放的原理" class="headerlink" title="直接内存分配与释放的原理"></a>直接内存分配与释放的原理</h4><p>通过代码来申请直接内存的大小，这里直接内存不受jvm管理，因此需要在任务管理器里查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer=ByteBuffer.allocateDirect(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>直接内存的回收是通过unsafe对象来进行回收的</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220119152850973.png" alt="image-20220119152850973"></p>
<h4 id="禁用显示回收的影响"><a href="#禁用显示回收的影响" class="headerlink" title="禁用显示回收的影响"></a>禁用显示回收的影响</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.gc（）     <span class="comment">//显式的垃圾回收</span></span><br></pre></td></tr></table></figure>

<p>关闭显示垃圾回收机制，即System.gc（）无效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC    </span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>即有一个引用该对象，则计数器加一，为0则释放，</p>
<p><strong>弊端</strong></p>
<p>循环引用：即A引用B,B也引用A，没有其他引用他们，但是他们互相引用，都无法释放，就会导致内存泄漏</p>
<h4 id="可达性分析算法（java中使用的垃圾回收机制）"><a href="#可达性分析算法（java中使用的垃圾回收机制）" class="headerlink" title="可达性分析算法（java中使用的垃圾回收机制）"></a>可达性分析算法（java中使用的垃圾回收机制）</h4><p><strong>根对象</strong>：肯定不可以当作垃圾回收的对象</p>
<p>如果一个对象没有被根对象引用，就可以回收</p>
<p><strong>解析</strong></p>
<p>扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</p>
<p><strong>抓取当前堆使用的快照</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump :format=b,live,file=<span class="number">1.</span>bin <span class="number">21384</span></span><br></pre></td></tr></table></figure>

<p>-dump ==》存储</p>
<p>format=b ==》存储二进制文件</p>
<p>live ==》只记录那些未被垃圾回收的内容</p>
<p>file=1.bin 设置存储文件</p>
<p>21384 进程id（jps获取活动的java的进程id）</p>
<p><strong>mat查看gc root对象</strong></p>
<p>System class 系统对象</p>
<p>Busy Monitor 加锁的对象</p>
<p>Thread 活动线程中的对象，局部对象所引用的对象可左gcroot，同时参数中对象也是可以作为gcroot对象</p>
<p><strong>可以作为GC Root的对象</strong></p>
<p>System class 系统对象</p>
<p>Busy Monitor 加锁的对象</p>
<p>Thread 活动线程中的对象，局部对象所引用的对象可左gcroot，同时参数中对象也是可以作为gcroot对象</p>
<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><p><img src="/hexo_blog/2022/01/21/jvm/image-20220119162157683.png" alt="image-20220119162157683"></p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>例如new出来的就是强引用</p>
<p><strong>特点</strong></p>
<ul>
<li>只要沿着gc root链可以找到该对象，就无法被垃圾回收，例B对A-A4，以及ByteBuffer</li>
<li>只要没有直接或则间接对其强引用之后就可以垃圾回收了</li>
</ul>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p><strong>特点</strong></p>
<ul>
<li>只要未被gc root直接引用，垃圾回收时就会自动回收，例从C到软引用再到A2，当然此时需要B不在引用A2时，就可以发生垃圾回收</li>
</ul>
<p><strong>应用场景</strong></p>
<p>强引用下导致堆空间溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 强引用会导致堆空间不够用</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">int</span> _1M=<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">     List&lt;<span class="keyword">byte</span>[]&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M*<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>软引用下</p>
<p>在这种方式下其实就是使用软引用进行嵌套强引用，也就是SoftReference嵌套byte数组，从而达到软引用的目的，这样一旦出现堆内存不够就会进行释放软引用对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">    SoftReference softReference=<span class="keyword">new</span> SoftReference(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M*<span class="number">2</span>]);</span><br><span class="line">    list.add(softReference);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个过程中一旦出现了堆空间不够，就会清理软引用对象引用的对象，但是此时软引用对象还在，虽然占据内存比较小，但最好还是清理一下</p>
<p>使用引用队列进行处理，下方代码，关联了软引用队列，软引用关联的对象回收时，软引用对象会加入队列中，从而实现回收</p>
<p>这里我个人的理解就是判断这些软引用有没有引用其他对象，如果没有，则将其在队列中删除，从而将队列对软引用对象的强引用解除掉，从而实现对象的回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 关联了软引用队列，软引用关联的对象回收时，软引用对象会加入队列中，从而实现回收</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; referenceQueue=<span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">     List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">         SoftReference softReference=<span class="keyword">new</span> SoftReference(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M*<span class="number">2</span>],referenceQueue);</span><br><span class="line">         list.add(softReference);</span><br><span class="line">     &#125;</span><br><span class="line">     Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = referenceQueue.poll();</span><br><span class="line">     <span class="keyword">while</span>(poll!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         referenceQueue.remove();</span><br><span class="line">         poll=referenceQueue.poll();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p><strong>特点</strong></p>
<ul>
<li>当没有强引用时，若内存不够会回收软引用的对象，无论够不够都会回收弱引用对象</li>
<li>释放之后，因为软弱引用仍占用空间，因此需将二者放入引用队列中，进行循环依次释放空间</li>
</ul>
<p><strong>应用实例</strong></p>
<h4 id="虚引用（必须配合引用队列）"><a href="#虚引用（必须配合引用队列）" class="headerlink" title="虚引用（必须配合引用队列）"></a>虚引用（必须配合引用队列）</h4><p><img src="/hexo_blog/2022/01/21/jvm/image-20220121110409118.png" alt="image-20220121110409118"></p>
<p>之前的bytebuffer就是需要一个虚引用对象Cleaner，因为ByteBuffer若是在强引用引用结束之后，会对其进行回收，但是此时直接内存不由jvm管理，这就需要把虚引用对象放置在引用队列中，从而实现对直接内存的回收（虚引用对象就是Cleaner，来调用Unsafe的Free memory（）来进行释放）</p>
<h4 id="终结器引用（必须配合引用队列）"><a href="#终结器引用（必须配合引用队列）" class="headerlink" title="终结器引用（必须配合引用队列）"></a>终结器引用（必须配合引用队列）</h4><p>例如A对象重写了finalize，并且A即将被垃圾回收，会调用finalize方法，将放置一个终结器引用到队列中，会有一个优先级很低的线程会来检查队列中有无需要释放的引用，从而实现对象的回收</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><ul>
<li>判断哪些对象未被gcroot对象引用，对其进行标记</li>
<li>对标记对象进行清除，将对象的首地址存储在队列中，在新的对象分配地址时，会在队列中进行查找，判断有无空间，在进行分配</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>清除速度快</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>会产生大量的碎片空间，导致总剩余空间虽然足够，但有些大空间对象仍无法分配到足够的内存，导致内存溢出</li>
</ul>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><ul>
<li>判断哪些对象未被gcroot对象直接或间接引用，对其进行标记</li>
<li>清楚时，将可用的对象向前移动，从而使得内存空间更见紧凑，从而实现空间更加连续</li>
</ul>
<p><strong>优点</strong></p>
<p>没有内存碎片</p>
<p><strong>缺点</strong></p>
<p>耗费时间较多，例如如果有引用对象引用就是将移动的对象，需要修改大量内容，造成浪费时间</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="/hexo_blog/2022/01/21/jvm/image-20220121121912340.png" alt="image-20220121121912340"></p>
<p>划分成两片区域，将from中存活的对对象复制到to中，待复制结束之后就对from所有的对象进行回收，然后交换from与to的位置</p>
<p><strong>优点</strong></p>
<ul>
<li>没有碎片空间</li>
</ul>
<p><strong>缺点</strong></p>
<p>需要占用双倍的内存空间</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>三种算法都会协同工作</p>
<h3 id="大对象直接到老年代"><a href="#大对象直接到老年代" class="headerlink" title="大对象直接到老年代"></a>大对象直接到老年代</h3><p>超过新生代大小时，直接到老年代中存放</p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p><img src="/hexo_blog/2022/01/21/jvm/image-20220121122327319.png" alt="image-20220121122327319"></p>
<ul>
<li>长时间使用的放在老年代中，用完即弃的放在新生代中，也可以认为重要的，常用的在老年代中，而不常使用的在新生代中</li>
<li>清理时先清理新生代，如果内存实在不够，再开始清理老年代</li>
</ul>
<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><ul>
<li>最开始对象存放在伊甸园中</li>
<li>一旦伊甸园中内存占满之后，就会开始触发垃圾回收<strong>（Minor GC，新生代回收）</strong></li>
<li>先进行标记，然后将存活的对象复制到幸存区，将复制的对象<strong>寿命+1</strong>.然后交换from与to的位置，伊甸园剩余的对象就可以销毁了</li>
<li>然后又可以向伊甸园中分配对象，直到伊甸园又满了，继续执行上述操作，并且也需要测试from中有没有可以回收的，最后在进行回收伊甸园中与幸存区的对象</li>
<li><strong>幸存区中的寿命超过一个阈值（最大寿命15次，存放寿命的数据是4bit，存放在对象里，4位）之后就会晋升到老年代中，若新生代承受不下了，即使没有到达阈值，也会放在老年代中</strong></li>
<li><strong>minor gc会引发 stop the world，在垃圾回收时需暂停其他用户的线程，直到垃圾回收之后在恢复其他线程的运行</strong></li>
</ul>
<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><ul>
<li>当老年代中内存不足，会先触发minor gc，如果之后空间仍不足，则会触发老年代回收<strong>（Full GC）</strong>，这次回收会将老年代中和新生代中的对象进行回收，也会引起stop the world，并且持续时间更长</li>
<li>老年代中存活的对象很多，并且采用的算法可能是标记清除或标记清理，时间会长。</li>
<li>若full gc 之后仍无从充足空间，则full of mememory error</li>
</ul>
<h3 id="GC参数"><a href="#GC参数" class="headerlink" title="GC参数"></a>GC参数</h3><table>
<thead>
<tr>
<th>含义</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>堆初始大小</td>
<td>-Xms</td>
</tr>
<tr>
<td>堆最大大小</td>
<td>-Xmx或-XX:MaxHeapSize =size</td>
</tr>
<tr>
<td>新生代大小</td>
<td>-Xmn或(-XX:NewSize-size + -XX:MaxNewSize-size )</td>
</tr>
<tr>
<td>幸存区比例(动态)</td>
<td>-XX:InitialSurvivorRatio-ratio和-XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td>幸存区比例（ratio是指伊甸园所在比例）</td>
<td>-XX:SurvivorRatio= ratio</td>
</tr>
<tr>
<td>晋升阈值</td>
<td>-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td>晋升详情</td>
<td>-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td>GC详情</td>
<td>-XX:+PrintGCDetails -verbose:ge</td>
</tr>
<tr>
<td>FullGC前MinorGC</td>
<td>-XX:+ScavengeBeforeFullGC</td>
</tr>
<tr>
<td>幸存区比例不会变化的垃圾回收器</td>
<td>-XX: +UseSerialGC</td>
</tr>
<tr>
<td>串行垃圾回收器（新生代是复制算法，老年是标记整理算法）</td>
<td>-XX:+UseSerialGC= Serial + Serialold</td>
</tr>
</tbody></table>
<h3 id="解析垃圾回收信息"><a href="#解析垃圾回收信息" class="headerlink" title="解析垃圾回收信息"></a>解析垃圾回收信息</h3><p><strong>设置的虚拟机参数：</strong></p>
<p>-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:ge</p>
<p><strong>控制台信息</strong></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220121201703726.png" alt="image-20220121201703726"></p>
<ul>
<li>new generation : 新生代  这里总容量9m的原因是因为默认认为to不可以被占用，因此就默认减去了1m<ul>
<li>eden ： 伊甸园</li>
<li>from ：幸存区的from区</li>
<li>to ： 幸存区的 to 区</li>
</ul>
</li>
<li>tenured generatioin ： 老年代</li>
<li>meta space : 元空间</li>
<li>后面的数字就是内存地址</li>
<li>默认的伊甸园占的比例是0.8</li>
</ul>
<h4 id="内存溢出在子线程会不会引起主线程结束"><a href="#内存溢出在子线程会不会引起主线程结束" class="headerlink" title="内存溢出在子线程会不会引起主线程结束"></a>内存溢出在子线程会不会引起主线程结束</h4><p>子线程的内存溢出并不会引起主线程结束</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><ul>
<li><strong>单线程</strong></li>
<li>适用于堆内存小，适合个人电脑</li>
</ul>
<p><strong>虚拟机参数</strong></p>
<p>-XX:+UseSerialGC= Serial + Serialold</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220122113807682.png" alt="image-20220122113807682"></p>
<p>所有的线程须达到安全点之后才可以执行垃圾回收</p>
<p>其他线程需要等到垃圾回收线程结束之后才可以开始继续运行</p>
<h3 id="吞吐量优先（垃圾回收时间占用总时间越少，吞吐量越高）"><a href="#吞吐量优先（垃圾回收时间占用总时间越少，吞吐量越高）" class="headerlink" title="吞吐量优先（垃圾回收时间占用总时间越少，吞吐量越高）"></a>吞吐量优先（垃圾回收时间占用总时间越少，吞吐量越高）</h3><ul>
<li>优先</li>
<li>适用于堆内存较大，多核cpu</li>
<li><strong>单位时间</strong>内stw时间最短（总体时间）</li>
</ul>
<p><strong>虚拟机配置（1.8默认的）</strong></p>
<p>并行的</p>
<p><strong>新生代的（复制算法）</strong>          <strong>老年代的（标记整理算法）</strong></p>
<p>-XX:+UseParallelGC              -XX: +UseParallelOldGC</p>
<p>开启上述其中一个，另一个会自动开启</p>
<p><strong>设置垃圾回收线程个数</strong></p>
<p>-XX: ParallelGCThreads=n</p>
<p><strong>自适应调整新生代的大小，晋升阈值也会受影响</strong></p>
<p>-XX;+UseAdaptivesizePolicy</p>
<p><strong>调整吞吐量的目标，调整垃圾回收与总时间的占比</strong></p>
<p>-XX:GCTimeRatio=ratio（垃圾回收时间比例=1/（1+ratio））</p>
<p><strong>最大暂停毫秒数，最大是200ms</strong></p>
<p>-XX:MaxGCPauseMillis=ms</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220122155817392.png" alt="image-20220122155817392"></p>
<p>也是所有线程到达安全点之后，就会开始多线程开始回收，线程个数与cpu核数有关，核数有多少，线程的上限就是多少</p>
<h3 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h3><ul>
<li>多线程</li>
<li>适用于堆内存较大，多核cpu</li>
<li>注重垃圾回收<strong>单次</strong>stop the world（stw）时间尽可能短</li>
</ul>
<p><strong>并发进行执行垃圾回收</strong></p>
<p>垃圾回收与普通线程同时进行，两类线程互相争夺时间片</p>
<p><strong>老年代</strong>  （标记清除）                                           <strong>新生代</strong></p>
<p>-XX:+UseConcMarkSweepGC   -XX:+UseParNewGC - SerialOld</p>
<p>一旦出现并发问题，老年代GC会退化为串行GC</p>
<p><strong>设置并行线程数</strong>                        <strong>设置并发线程数，建议设置为并行线程数的四分之一</strong></p>
<p>-XX :ParallelGCThreads=n     -XX:ConcGCThreads=threads</p>
<p><strong>只要老年代到达percent之后，就进行清理，是给浮动垃圾留空间</strong></p>
<p>-XX:CMSInitiating0ccupancyFraction=percent</p>
<p><strong>做重新标记之前，先把新生代做一次垃圾回收</strong></p>
<p>这里的原因是因为有新生代要回收的有很多，而且可能新生代还引用了老年代，但这些新生代本身就已经要被清除了，所以即使我们通过他们发现了一些老年代不能进行回收，但是后期这些新生代本身就要进行回收，实际上了做了无用功，因此可以提前对其进行清理，从而达到减少时间的目的</p>
<p>-XX:+CMSScavengeBeforeRemark</p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220122162126627.png" alt="image-20220122162126627"></p>
<ul>
<li>初始标记只会标记根对象，此时很快，但是会引发stw</li>
<li>并发标记会标记间接或直接引用的对象，此时与用户线程并发运行</li>
<li>并发标记后会及逆行重新标记，会引起stw（因为并发标记时，标记的内容可能地址会进行改变，因此需重新标记）</li>
<li>重新标记之后会进行并发处理</li>
<li>并发清理过程中，其他线程可能又会有新垃圾（浮动垃圾），这些垃圾下次处理，因此需要专门设置浮动垃圾空间</li>
</ul>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p><img src="/hexo_blog/2022/01/21/jvm/image-20220118162509588.png" alt="image-20220118162509588"></p>
<p><img src="/hexo_blog/2022/01/21/jvm/image-20220118165503266.png" alt="image-20220118165503266"></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="string">&quot;123&quot;</span></span><br><span class="line">String b=<span class="string">&quot;55&quot;</span></span><br><span class="line">String c=a+b</span><br></pre></td></tr></table></figure>

<p>c的赋值其实是先调用Stringbuilder的toString方法生成一个新的String对象，然后返回给c</p>
<p>但是如下图这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="string">&quot;a&quot;</span></span><br><span class="line">String b=<span class="string">&quot;b&quot;</span></span><br><span class="line">String c=<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>;</span><br><span class="line">String d=<span class="string">&quot;ab&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时，c==d是true，因为在编译时，javac会默认认为”a”+”b”就是”ab”，因此直接调用常量池的内容就可以</p>
<h3 id="主动将字符串对象放入串池"><a href="#主动将字符串对象放入串池" class="headerlink" title="主动将字符串对象放入串池"></a>主动将字符串对象放入串池</h3><p>itern（）：将字符串对象放入串池，若不存在，则放入，否则不进行放入</p>
<h2 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p><img src="/hexo_blog/2022/01/21/jvm/image-20220121113317503.png" alt="image-20220121113317503"></p>
<p>原来的占用内存-&gt;回收后的内存，Full GC表示垃圾回收资源太少，因此采用更加强烈的垃圾回收，即软链接垃圾回收</p>
<p>初次回收时会将所有的弱引用对象引用的对象回收掉，若是回收之后内存依然不够，会对软引用在进行回收</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发：并发是指两个或多个事件在同一时间间隔发生</p>
<p>并行：并行是指两个或者多个事件在同一时刻发生。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>jvm</p><p><a href="https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/">https://xiaow123.gitee.io/hexo_blog/2022/01/21/jvm/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>xiaow</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-01-21</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-01-22</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/hexo_blog/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/hexo_blog/img/wechat.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">jvm续集</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/hexo_blog/2021/10/22/%E7%8E%A9%E7%88%AC%E8%99%AB%E4%B8%8D%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93you-get%EF%BC%8C%E5%BF%AB%E8%BF%9B%E6%9D%A5%E7%9C%8B%E7%9C%8B/"><span class="level-item">玩爬虫不能不知道you-get，快进来看看</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "eAQOmVvdKBTqHRuobS1EqWsT-gzGzoHsz",
            appKey: "l2cLXEXgWc8FIeYcImwr2mXS",
            placeholder: "发一条评论吧，评论的时候别忘记在上面写上你的名字和邮箱，方便我们联系",
            
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/hexo_blog/img/123.jpg" alt="XiaoW"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">XiaoW</p><p class="is-size-6 is-block">keep coding keep go on</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>山东</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/hexo_blog/archives"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/hexo_blog/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/hexo_blog/tags"><p class="title">5</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gitee.com/xiaow123" target="_blank" rel="noopener">关注我</a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://gitee.com/xiaow123" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/qq_43627076" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">csdn</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/hexo_blog/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/categories/%E7%88%AC%E8%99%AB/"><span class="level-start"><span class="level-item">爬虫</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/categories/%E9%9A%8F%E7%AC%94/"><span class="level-start"><span class="level-item">随笔</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-12T12:09:33.000Z">2022-02-12</time></p><p class="title"><a href="/hexo_blog/2022/02/12/jvm%E7%BB%AD%E9%9B%862/">jvm续集2</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-07T04:02:58.000Z">2022-02-07</time></p><p class="title"><a href="/hexo_blog/2022/02/07/%E8%A7%86%E9%A2%91%E5%88%92%E5%88%86%E4%B8%BAts%E7%89%87%E6%AE%B5/">视频划分为ts片段</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-22T08:51:20.000Z">2022-01-22</time></p><p class="title"><a href="/hexo_blog/2022/01/22/jvm%E7%BB%AD%E9%9B%86/">jvm续集</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-21T08:00:40.000Z">2022-01-21</time></p><p class="title"><a href="/hexo_blog/2022/01/21/jvm/">jvm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-22T15:55:27.000Z">2021-10-22</time></p><p class="title"><a href="/hexo_blog/2021/10/22/%E7%8E%A9%E7%88%AC%E8%99%AB%E4%B8%8D%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93you-get%EF%BC%8C%E5%BF%AB%E8%BF%9B%E6%9D%A5%E7%9C%8B%E7%9C%8B/">玩爬虫不能不知道you-get，快进来看看</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/hexo_blog/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo_blog/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/Harmony/"><span class="tag">Harmony</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E7%88%AC%E8%99%AB/"><span class="tag">爬虫</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/hexo_blog/tags/%E9%9A%8F%E7%AC%94/"><span class="tag">随笔</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/hexo_blog/"><img src="/hexo_blog/img/logo.svg" alt="xiaow的博客" height="28"></a><p class="is-size-7"><span>&copy; 2022 xiaow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/hexo_blog/js/column.js"></script><script src="/hexo_blog/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/hexo_blog/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/hexo_blog/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/hexo_blog/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/hexo_blog/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>